3151. Special Array I
class Solution:
    def isArraySpecial(self, nums: List[int]) -> bool:
        for i in range(len(nums)-1):
            if nums[i]%2 == nums[i+1]%2:
                return False
        return True

1752. Check if Array Is Sorted and Rotated
class Solution:
    def check(self, nums: List[int]) -> bool:
        c=0
        n=len(nums)
        for i in range(n):
            if nums[i]>nums[(i+1)%n]:
                c+=1
        if c>1:
            return False
        return True

3105. Longest Strictly Increasing or Strictly Decreasing Subarray
class Solution:
    def longestMonotonicSubarray(self, nums: List[int]) -> int:
        c=1
        r=1
        inc=0
        for i in range(1,len(nums)):
            if nums[i-1]<nums[i]:
                if inc>0:
                    c+=1
                else:
                    c=2
                    inc=1
            elif nums[i-1]>nums[i]:
                if inc<0:
                    c+=1
                else:
                    c=2
                    inc=-1
            else:
                c=1
                inc=0
            r=max(r,c)
        return r
1800. Maximum Ascending Subarray Sum
class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        c=nums[0]
        r=c
        for i in range(1,len(nums)):
            if not (nums[i-1]<nums[i]):
                c=0
            c+=nums[i]
            r=max(r,c)
        return r
1790. Check if One String Swap Can Make Strings Equal
class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        ind=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                ind.append(i)
            if len(ind)>2:
                return False
        if len(ind)==2:
            i,j=ind
            return s1[i]==s2[j] and s1[j]==s2[i]
        return len(ind)==0

1726. Tuple with Same Product
class Solution:
    def tupleSameProduct(self, nums: List[int]) -> int:
        d={}
        a=0
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                p=nums[i]*nums[j]

                if p in d:
                    a+=(d[p]*8)
                    d[p]+=1
                else:
                    d[p]=1
        return a

3160. Find the Number of Distinct Colors Among the Balls
class Solution:
    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:
        n=len(queries)
        ans=[0]*n
        mp={}
        color=defaultdict(int)
        i=0
        for x, c in queries:
            if x in mp:
                c0=mp[x]
                color[c0]-=1
                if color[c0]==0:
                    color.pop(c0)
            mp[x]=c
            color[c]+=1
            ans[i]=len(color)
            i+=1
        return ans
        
2349. Design a Number Container System
class NumberContainers:

    def __init__(self):
        self.mp={}
        self.idx=defaultdict(list)

    def change(self, index: int, number: int) -> None:
        self.mp[index]=number
        heappush(self.idx[number], index)
        

    def find(self, number: int) -> int:
        if number not in self.idx:
            return -1
        while self.idx[number]:
            i=self.idx[number][0]
            if self.mp[i]==number: return i
            heappop(self.idx[number])
        return -1
--- 9-2-2025
3174. Clear Digits
class Solution:
    def clearDigits(self, s: str) -> str:
        k=0
        s=list(s)
        for i,c in enumerate(s):
            if c.isdigit() and k>0:
                k-=1
            else:
                s[k]=c
                k+=1
        s=s[:k]
        return "".join(s) 
1910. Remove All Occurrences of a Substring
class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        while part in s:
            s=s.replace(part,"",1)
        return s
2342. Max Sum of a Pair With Equal Sum of Digits
class Solution:
    def maximumSum(self, nums: List[int]) -> int:
        def sum_digit(i):
            sum=0
            while(i):
                sum+=i%10
                i//=10
            return sum
        pairs=[]
        for n in nums:
            sum=sum_digit(n)
            pairs.append((sum,n))
        pairs.sort()
        max_sum=-1
        for i in range(1,len(nums)):
            if pairs[i][0]==pairs[i-1][0]:
                present=pairs[i][1]+pairs[i-1][1]
                max_sum=max(max_sum,present)
        return max_sum
3066. Minimum Operations to Exceed Threshold Value II

class Solution(object):
    def minOperations(self, nums, k):
        heapq.heapify(nums)
        res=0

        for i in range(0, len(nums)):
            x=heapq.heappop(nums)
            if x<k:
                res+=1
                y=heapq.heappop(nums)
                val= x*2+y if (x<y) else y*2+x
                heapq.heappush(nums, val)
            else:
                break

        return res

1352. Product of the Last K Numbers
class ProductOfNumbers:

    def __init__(self):
        self.product=[1]
        self.n=1

    def add(self, num: int) -> None:
        if num==0:
            self.product=[1]
            self.n=1
        else:
            self.product.append(self.product[-1]*num)
            self.n+=1

    def getProduct(self, k: int) -> int:
        if self.n<=k:
            return 0
        else:
            return self.product[-1]//self.product[-k-1]
        


# Your ProductOfNumbers object will be instantiated and called as such:
# obj = ProductOfNumbers()
# obj.add(num)
# param_2 = obj.getProduct(k)

2698. Find the Punishment Number of an Integer
class Solution:
    def punishmentNumber(self, n: int) -> int:
        arr = [1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,
               657,675,703,756,792,909,918,945,964,990,991,999,1000]
        
        total = 0
        for num in arr:
            if num <= n:
                total += num * num
            else:
                break
        return total
1718. Construct the Lexicographically Largest Valid Sequence
class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        len_seq = 2 * n - 1
        seq = [0] * len_seq 
        used = set() 
        def backtrack(i):
            if i == len_seq: return True 
            if seq[i]: return backtrack(i + 1) 

            for num in range(n, 0, -1): 
                if num in used: continue 

                nxt = i + num if num > 1 else i 

                if nxt >= len_seq or seq[nxt] != 0: continue 
                
                seq[i] = seq[nxt] = num 
                used.add(num)

                if backtrack(i + 1): 
                    return True

                seq[i] = seq[nxt] = 0 
                used.remove(num)

            return False 

        backtrack(0)
        return seq 
1079. Letter Tile Possibilities
class Solution:
    def numTilePossibilities(self, tiles: str) -> int:
        return len(set(p for i in range(1, len(tiles)+1) for p in permutations(tiles, i)))
2375. Construct Smallest Number From DI String
class Solution:
    def smallestNumber(self, pattern: str) -> str:
        stack = ['', '1']  
        prev = pattern[0] 
        for num, i in enumerate(pattern + 'S', 2): 
            if i != prev: 
                if prev == 'D': 
                    stack[-2] = stack[-2][:-1] + stack[-1][::-1]
                else:  
                    stack[-2] = stack[-2][:-1] + stack[-1]
                stack[-1] = stack[-2][-1] + str(num)
                prev = i
            else:
                stack[-1] += str(num)
        
        return stack[0] 
1415. The k-th Lexicographical String of All Happy Strings of Length n
class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        count = 0 
        def backtrack(i, chars):
            nonlocal count
            if i == n: 
                count += 1 
                return "".join(chars) if count == k else ""    
            for c in "abc": 
                if chars and chars[-1] == c: continue 
                res = backtrack(i + 1, chars + [c]) 
                if res:
                    return res 
            return ""     
        return backtrack(0, [])
1980. Find Unique Binary String
class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        r=[]
        for i in range(0,len(nums)):
            if nums[i][i]=='0':
                r.append('1')
            else:
                r.append('0')
        return "".join(r)
1261. Find Elements in a Contaminated Binary Tree
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class FindElements:

    def __init__(self, root: Optional[TreeNode]):
        self.hasX=set()
        def bfs(root):
            q=deque()
            root.val=0
            q.append(root)

            while q:
                node=q.popleft()
                x=node.val
                self.hasX.add(x)

                if node.left:
                    node.left.val=2*x+1
                    q.append(node.left)
                if node.right:
                    node.right.val=2*x+2
                    q.append(node.right)
        bfs(root)
        

    def find(self, target: int) -> bool:
        return target in self.hasX
        


# Your FindElements object will be instantiated and called as such:
# obj = FindElements(root)
# param_1 = obj.find(target)

1028. Recover a Tree From Preorder Traversal
class Solution:
    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:
        nodes = [(len(node[1]), int(node[2])) for node in re.findall("((-*)(\d+))", traversal)][::-1]
        def makeTree(depth): 
            if not nodes or depth != nodes[-1][0]: return None 
            node = TreeNode(nodes.pop()[1])
            node.left = makeTree(depth + 1)  
            node.right = makeTree(depth + 1)

            return node

        return makeTree(0) 
889. Construct Binary Tree from Preorder and Postorder Traversal
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not preorder and not postorder:
            return None
        root=TreeNode(preorder[0])
        if len(preorder)==1:
            return root
        left_root_val=preorder[1]
        left_subtree_size=postorder.index(left_root_val)+1
        root.left=self.constructFromPrePost(preorder[1:left_subtree_size+1],postorder[:left_subtree_size])
        root.right=self.constructFromPrePost(preorder[left_subtree_size+1:],postorder[left_subtree_size:-1])
        return root
2467. Most Profitable Path in a Tree
class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        n=len(edges)+1
        adj=[[] for _ in range(n)]
        parent=[-1]*n
        Bob=[float('inf')]*n 

        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        def dfs(i, p):
            parent[i] = p
            for j in adj[i]:
                if j == p: continue
                dfs(j, i)

        dfs(0, -1)  
        x=bob
        move=0
        while x!=-1:
            Bob[x]=move
            move+=1
            x=parent[x]
        def dfs_sum(i, dist, prev):
            alice=0
            if dist < Bob[i]:
                alice=amount[i]  
            elif dist==Bob[i]:
                alice=amount[i]//2  

            isLeaf=True
            maxLeafSum=-float('inf')

            for j in adj[i]:
                if j == prev: continue
                isLeaf=False
                maxLeafSum = max(maxLeafSum, dfs_sum(j, dist+1, i))

            return alice if isLeaf else alice + maxLeafSum

        return dfs_sum(0, 0, -1)
1524. Number of Sub-arrays With Odd Sum
class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        sum_is_odd=0
        cnt=[1, 0]
        ans=0
        for x in arr:
            sum_is_odd^=(x&1)
            ans+=cnt[1-sum_is_odd]
            cnt[sum_is_odd]+=1
        return ans%(10**9+7)  
        
1524. Number of Sub-arrays With Odd Sum
class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        sum_is_odd=0
        cnt=[1, 0]
        ans=0
        for x in arr:
            sum_is_odd^=(x&1)
            ans+=cnt[1-sum_is_odd]
            cnt[sum_is_odd]+=1
        return ans%(10**9+7)
1749. Maximum Absolute Sum of Any Subarray
class Solution:
    def maxAbsoluteSum(self, nums: List[int]) -> int:
        return max(0, max(K:=list(accumulate(nums))))-min(0, min(K))
873. Length of Longest Fibonacci Subsequence
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        fib_lens = {}
        set_arr = set(arr) 

        for b, c in combinations(arr, 2):
            a = c - b 
            if a < b and a in set_arr: 
                fib_lens[(b, c)] = fib_lens.get((a, b), 2) + 1
                
        return max(fib_lens.values(), default = 0) 
1092. Shortest Common Supersequence 
class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        i, j = m, n
        scs = []
    
        while i > 0 or j > 0:
            if i > 0 and j > 0 and str1[i - 1] == str2[j - 1]:  
                scs.append(str1[i - 1])
                i -= 1
                j -= 1
            elif i > 0 and (j == 0 or dp[i - 1][j] >= dp[i][j - 1]): 
                scs.append(str1[i - 1])
                i -= 1
            else: 
                scs.append(str2[j - 1])
                j -= 1
    
        scs.reverse()
        return "".join(scs)     
2460. Apply Operations to an Array
class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        n, i=len(nums), 0
        while i<n-1:
            if nums[i]==nums[i+1]:
                nums[i], nums[i+1]=nums[i]<<1, 0
                i+=1
            i+=1
        j=0
        for x  in nums:
            if x>0:
                nums[j]=x
                j+=1
        nums[j:]=[0]*(n-j)
        return nums
2570. Merge Two 2D Arrays by Summing Values
class Solution:
    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        d={}
        for i in nums1:
            if i[0] not in d:
                d[i[0]]=i[1]
            else:
                d[i[0]]+=i[1]
        for i in nums2:
            if i[0] not in d:
                d[i[0]]=i[1]
            else:
                d[i[0]]+=i[1]
        ans=[]
        # print(d)
        for i in sorted(d.keys()):
            l=[]
            l.append(i)
            l.append(d[i])
            ans.append(l)

        return ans
2161. Partition Array According to Given Pivot
class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        x=[]
        y=[]
        z=[]
        for i in nums:
            if i==pivot:
                z.append(i) 
            elif i<pivot:
                x.append(i)
            else :
                y.append(i)
        return x+z+y
1780. Check if Number is a Sum of Powers of Three
class Solution:
    def checkPowersOfThree(self, n: int) -> bool:
        while n>0:
            q, r=divmod(n, 3)
            if r==2: return False
            n=q
        return True
2579. Count Total Number of Colored Cells
class Solution:
    def coloredCells(self, n: int) -> int:
        return 2*n*(n-1)+1
2965. Find Missing and Repeated Values
class Solution:
    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:
        n = len(grid)
        missing = (n * n) * (1 + n * n) // 2 
        seen = set() 
        duplicate = -1
        for row in grid:
            for num in row:
                if num not in seen:
                    seen.add(num)
                    missing -= num 
                else:
                    duplicate = num
                    
        return [duplicate, missing]
2523. Closest Prime Numbers in Range
class Solution:
        
    def closestPrimes(self, left: int, right: int) -> List[int]:
        def primeFind(val: int)->bool:
            if val==1: return False
            elif val==2: return True

            for i in range(2, int(val**0.5)+1):
                if val%i==0:
                    return False
            return True

        res=[-1,-1]
        prime=[]

        for p in range(left, right+1):
            if primeFind(p):
                if len(prime)>=1 and p<=prime[len(prime)-1]+2:
                    return [prime[len(prime)-1], p]
                prime.append(p)
        

        if len(prime)<2:
            return res

        minVal=sys.maxsize
        for i in range(1, len(prime)):
            if minVal>prime[i]-prime[i-1]:
                minVal=prime[i]-prime[i-1]
                res=[prime[i-1], prime[i]] 

        return res
2379. Minimum Recolors to Get K Consecutive Black Blocks
class Solution:
    def minimumRecolors(self, blocks: str, k: int) -> int:
        n=len(blocks)
        recolor=W=blocks[:k].count('W')
        for l in range(n-k):
            W+=(blocks[l+k]=='W')-(blocks[l]=='W')
            recolor=min(recolor, W)
        return recolor
3208. Alternating Groups II
class Solution:
    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:
        n=len(colors)
        s=n+k-1
        ans, alt, prev=0, 1, colors[0]
        for i in range(1, s):
            i0=i%n
            alt=1 if prev==colors[i0] else alt+1
            ans+=(alt>=k)
            prev=colors[i0]
        return ans
3306. Count of Substrings Containing Every Vowel and K Consonants II
class Solution:
    def countOfSubstrings(self, word: str, k: int) -> int:
        n = len(word)
        vowels = set('aeiou')
        vowel_count, cons_count = defaultdict(int), 0 
        left = count = substrs = 0 

        def minus_char(char):
            if char in vowels:
                vowel_count[char] -= 1
                if vowel_count[char] == 0:
                    del vowel_count[char] 
            else:
                nonlocal cons_count
                cons_count -= 1

        for char in word:
            if char in vowels:
                vowel_count[char] += 1
            else:
                cons_count += 1
                count = 0

            while cons_count > k: 
                minus_char(word[left])
                left += 1
            while cons_count == k and len(vowel_count) == 5:
                count += 1 
                minus_char(word[left])
                left += 1 
            substrs += count

        return substrs
1358. Number of Substrings Containing All Three Characters
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        n, cnt, letter, l=len(s), 0, 0, 0
        freq=[0]*3
        for r, c in enumerate(s):
            freq[ord(c)-97]+=1
            if freq[ord(c)-97]==1: letter+=1
            while letter==3:
                freq[ord(s[l])-97]-=1
                if freq[ord(s[l])-97]==0: letter-=1
                l+=1
            cnt+=l
        return cnt
2529. Maximum Count of Positive Integer and Negative Integer
class Solution:
    def maximumCount(self, nums: List[int]) -> int:
        return max(len(nums)-bisect_right(nums,0), bisect_left(nums, 0))
3356. Zero Array Transformation II
class Solution:
    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:
        n, m=len(nums), len(queries)
        freq=[0]*(n+1)
        op, k=0, 0
        for i in range(n):
            while op<nums[i]-freq[i]:
                if k>=m: 
                    return -1
                l, r, v=queries[k]
                if r<i:
                    k+=1 
                    continue
                freq[max(l, i)]+=v
                freq[r+1]-=v
                k+=1
            op+=freq[i]
        return k 
2226. Maximum Candies Allocated to K Children
class Solution:
    def maximumCandies(self, candies: List[int], k: int) -> int:
        def get_c(c, k):
            for x in candies:
                k-=x//c
                if k<=0: 
                    return True
            return False
        Sum=sum(candies)
        if Sum<k: 
            return 0
        l, r=1, Sum//k
        while l<r:
            m=(l+r+1)//2
            if get_c(m, k): 
                l=m
            else: 
                r=m-1
        return l
2560. House Robber IV
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        n=len(nums)
        x0=min(nums)
        xM=max(nums)
        def f(cap):
            steal, i=0, 0
            while i<n and steal<=k:
                if nums[i]<=cap:
                    steal+=1
                    i+=1
                i+=1
            return steal>=k

        l, r=x0, xM
        while l<r:
            m=(l+r)>>1
            if f(m):
                r=m
            else:
                l=m+1
        return l
2594. Minimum Time to Repair Cars
class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        freq=Counter(ranks)
        minR=min(ranks)
    #    maxR=max(ranks) # no need
        def canRepair(t):
            cnt=0
            for x, f in freq.items():
                cnt+=f*(sqrt(t/x)//1)
                if cnt>=cars: return True
            return cnt>=cars
        
        l, r=1, minR*cars*cars
        while l<r:
            m=(l+r)>>1
            if canRepair(m):
                r=m
            else:
                l=m+1
        return l
Divide Array Into Equal Pairs
class Solution:
    def divideArray(self, nums: List[int]) -> bool:
        a=0
        for i in nums:
            a^=(1<<i)
        return a==0
2401. Longest Nice Subarray
class Solution:
    def longestNiceSubarray(self, nums: List[int]) -> int:
        n, ans, B, l=len(nums), 0, 0, 0
        for r, x in enumerate(nums):
            while l<r and (B& x)!=0:
                B^=nums[l]
                l+=1
            B|=x
            ans=max(ans, r-l+1)
        return ans
3191. Minimum Operations to Make Binary Array Elements Equal to One I
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n, i0, op = len(nums), -1, 0
        nums.append(0) 
        while True:
            i0 = nums.index(0, i0+1)  
            if i0 >= n-2:  
                break  
            nums[i0+1] ^=1 
            nums[i0+2] ^=1 
            op+=1  
        return op if i0>=n else -1  
3108. Minimum Cost Walk in Weighted Graph
from typing import List

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.weights = [131071] * n  
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y, w):
        repX = self.find(x)
        repY = self.find(y)
        if repX != repY:
            if self.rank[repX] >= self.rank[repY]:
                self.parent[repY] = repX
                self.rank[repX] += self.rank[repY]
            else:
                self.parent[repX] = repY
                self.rank[repY] += self.rank[repX]
        self.weights[repX] = self.weights[repY] = self.weights[repX] & self.weights[repY] & w

    def path_weight(self, node):
        return self.weights[self.find(node)]

class Solution:
    def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:
        dsu = UnionFind(n)
        for u, v, w in edges:
            dsu.union(u, v, w)

        res = []
        for s, t in query:
            if dsu.find(s) == dsu.find(t):
                res.append(dsu.path_weight(s))
            else:
                res.append(-1)

        return res
2115. Find All Possible Recipes from Given Supplies
class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]: 
        supplies = set(supplies)
        recipes = dict(zip(recipes, ingredients))
        made = []
        while True:
            new_recipe_made = False
            for rcp, igs in [*recipes.items()]:
                if not all(i in supplies for i in igs):
                    continue
                made.append(rcp)
                supplies.add(rcp)
                del recipes[rcp]
                new_recipe_made = True

            if not new_recipe_made: 
                break
        return made
2685. Count the Number of Complete Components
class UnionFind:
    def __init__(self, N):
        self.root = list(range(N))
        self.Size = [1]*N

    def Find(self, x):
        if self.root[x] != x:
            self.root[x] = self.Find(self.root[x])  # path compression
        return self.root[x]

    def Union(self, x, y):
        x = self.Find(x)
        y = self.Find(y)
        if x==y: return False

        if self.Size[x] > self.Size[y]:
            self.Size[x] += self.Size[y]
            self.root[y]=x
        else:
            self.Size[y] += self.Size[x]
            self.root[x]=y
        return True
class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        m=len(edges)
        if m==n*(n-1)//2: 
            return 1

        G=UnionFind(n)
        eN=[0]*n
        for v, w in edges:
            a=eN[G.Find(v)]
            b=eN[G.Find(w)]
            if G.Union(v, w):
                eN[G.Find(v)]=a+b+1
            else:
                eN[G.Find(v)]=a+1
        ans=0
        for i, v in enumerate(G.Size):
            if G.Find(i)==i and eN[i]==v*(v-1)//2:
                ans+=1
        return ans
1976. Number of Ways to Arrive at Destination
from typing import List
from collections import defaultdict
import heapq

class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        MOD = 10**9 + 7

        # Build the graph
        graph = defaultdict(list)
        for u, v, time in roads:
            graph[u].append((v, time))
            graph[v].append((u, time))

        # Dijkstra's initialization
        min_heap = [(0, 0)]  # (time, node)
        shortest_time = [float('inf')] * n
        pathCount = [0] * n
        shortest_time[0] = 0
        pathCount[0] = 1

        while min_heap:
            curr_time, u = heapq.heappop(min_heap)

            # Skip if we already found a better time
            if curr_time > shortest_time[u]:
                continue

            for v, t in graph[u]:
                new_time = curr_time + t

                if new_time < shortest_time[v]:
                    shortest_time[v] = new_time
                    pathCount[v] = pathCount[u]
                    heapq.heappush(min_heap, (new_time, v))

                elif new_time == shortest_time[v]:
                    pathCount[v] = (pathCount[v] + pathCount[u]) % MOD

        return pathCount[n - 1] % MOD
3169. Count Days Without Meetings
class Solution:
    def countDays(self, days: int, meetings: list[list[int]]) -> int:
        t = 0
        for i, j in sorted(meetings, key=lambda x: x[0]):
            if j <= t:
                continue
            elif i > t:
                days -= j - i + 1
            else:
                days -= j - t
            t = j
            
        return days
3394. Check if Grid can be Cut into Sectionsclass Solution:
    def checkValidCuts(self, n: int, a: List[List[int]]) -> bool:
        sx,sy,ex,ey = zip(*a)
        return any(sum(starmap(le,zip(accumulate([0,*b],max),a)))>2
            for a,b in starmap(zip,map(sorted,map(zip,(sx,sy),(ex,ey))))
        )
2033. Minimum Operations to Make a Uni-Value Grid
class Solution:
    def minOperations(self, grid: List[List[int]], x: int) -> int:
        arr = [num for row in grid for num in row]  
        arr.sort()
        median = arr[len(arr) // 2]  
        for num in arr:
            if (num - median) % x != 0:
                return -1  
        return sum(abs(num - median) // x for num in arr)
2780. Minimum Index of a Valid Split
class Solution:
    def minimumIndex(self, nums: List[int]) -> int:
        c= 0
        d, c1 = max(Counter(nums).items(), key=lambda x: x[1])
        for i, x in enumerate(nums):
            c+= x == d
            c1-= x == d
            if c> (i + 1) // 2 and c1 > (len(nums) - (i + 1)) // 2:
                return i
        return -1
2503. Maximum Number of Points From Grid Queries
class Solution:
    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:
        m, n = len(grid), len(grid[0])

        visited = set([(0, 0)])
        visiting = [(0, 0)]
        dropped = []

        scores = {}
        curr_score = 0

        for q in sorted(set(queries)):
            while visiting:
                next_visit = []
                for x, y in visiting:
                    if grid[x][y] < q:
                        curr_score += 1
                        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
                            if 0 <= x + dx and m > x + dx and \
                                0 <= y + dy and n > y + dy and \
                                (x + dx, y + dy) not in visited:
                                next_visit.append((x + dx, y + dy))
                                visited.add((x + dx, y + dy))
                    else:
                        dropped.append((x, y))
                visiting = next_visit
            scores[q] = curr_score
            visiting = dropped
            dropped = []

        return [scores.get(q, 0) for q in queries ]
2818. Apply Operations to Maximize Score
class Solution:
    def countDistinctPrimeFactors(self, n: int) -> int:
        count = 0
        if n % 2 == 0:
            count += 1
            while n % 2 == 0:
                n //= 2
        
        i = 3
        while i * i <= n:
            if n % i == 0:
                count += 1
                while n % i == 0:
                    n //= i
            i += 2 
        if n > 1:
            count += 1
        return count

    def modPow(self, base: int, exp: int, mod: int) -> int:
        result = 1
        b = base % mod
        while exp > 0:
            if exp & 1:
                result = (result * b) % mod
            b = (b * b) % mod
            exp >>= 1
        return result

    def maximumScore(self, nums: List[int], k: int) -> int:
        MOD = 1_000_000_007
        n = len(nums)
        if n == 0:
            return 1

        maxValues = [(-nums[i], i) for i in range(n)]  # Min heap with negative values for max heap behavior
        heapq.heapify(maxValues)
        
        rightLarge = [n] * n
        leftLarge = [-1] * n
        primeScores = [self.countDistinctPrimeFactors(nums[i]) for i in range(n)]
        
        stack = []
        for i in range(n):
            while stack and primeScores[i] > primeScores[stack[-1]]:
                rightLarge[stack.pop()] = i
            stack.append(i)
        
        stack.clear()
        for i in range(n - 1, -1, -1):
            while stack and primeScores[i] >= primeScores[stack[-1]]:
                leftLarge[stack.pop()] = i
            stack.append(i)

        score = 1

        while maxValues and k > 0:
            val, idx = heapq.heappop(maxValues)
            val = -val  # Convert back to positive

            t = (rightLarge[idx] - idx) * (idx - leftLarge[idx])
            steps = min(t, k)

            multiply = self.modPow(val, steps, MOD)
            score = (score * multiply) % MOD

            k -= steps

        return score % MOD
763. Partition Labels
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        letters = set()
        first = {}
        last = {}
        ranges = []
        for i in range(len(s)):
            letter = s[i]
            letters.add(letter)
            if letter not in first:
                first[letter] = i
                last[letter] = i
            else:
                last[letter] = i
        for letter in letters:
            ranges.append([first[letter], last[letter]])
        ranges.sort()
        merged = [ranges[0]]
        for r in ranges[1:]:
            start, end = merged[-1]
            new_start, new_end = r
            if new_start < end:
                merged[-1] = [start, max(end, new_end)]
            else:
                merged.append(r)
        return [end - start + 1 for start, end in merged]

2551. Put Marbles in Bags
class Solution:
    def putMarbles(self, weights: List[int], k: int) -> int:
        if k == 1 or  k == len(weights):
            return 0
        pair_sums = []
        for i in range(len(weights) - 1):
            pair_sums.append(weights[i] + weights[i+1])
        pair_sums.sort()
        min_score = sum(pair_sums[:k-1])
        max_score = sum(pair_sums[-(k-1):])   
        return max_score - min_score
2140. Solving Questions With Brainpower
class Solution:
    def mostPoints(self, questions: List[List[int]]) -> int:
        n = len(questions)
        dp = [q[0] for q in questions]

        for i in range(n-2,-1,-1):
            out_range = i + questions[i][1] + 1
            if out_range < n:
                dp[i] += dp[out_range]
            dp[i] = max(dp[i],dp[i+1])
        return dp[0]
2874. Maximum Value of an Ordered Triplet II
class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        n=len(nums)
        L=[0]*n
        R=[0]*n
        for i in range(n-1):
            L[i+1]=max(L[i], nums[i])
            R[n-2-i]=max(R[n-i-1], nums[n-i-1])
        return max(0,max((L[i]-nums[i])*R[i] for i in range(1, n-1)))
1123. Lowest Common Ancestor of Deepest Leaves
1123. Lowest Common Ancestor of Deepest Leaves# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def dfs(node):
            if not node: return (0, None) # (depth, lca)
            l, llca = dfs(node.left)
            r, rlca = dfs(node.right)
            if l == r: return (l + 1, node)
            return (l + 1, llca) if l > r else (r + 1, rlca)
        return dfs(root)[1]
1863. Sum of All Subset XOR Totals
class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0
        for i in range(1 << n):
            x = 0
            for j in range(n):
                if (1 << j) & i:
                    x ^= nums[j]
            res += x
        return res
368. Largest Divisible Subset
class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        dp = [[num] for num in nums]

        for i in range(len(nums)):
            for j in range(i):
                if nums[i] % nums[j] == 0 and len(dp[j]) + 1 > len(dp[i]):
                    dp[i] = dp[j] + [nums[i]]

        return max(dp, key=len)

416. Partition Equal Subset Sum
class Solution:
    def canPartition(self, nums: list[int]) -> bool:
        target, isOdd = divmod(sum(nums), 2)
        if isOdd: return False
        bitmap = 1
        for num in nums: bitmap|= bitmap << num
        return bool(bitmap & (1 << target)) 
3396. Minimum Number of Operations to Make Elements in Array Distinct
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        a=0
        while len(nums)>len(set(nums)):
            nums=nums[3:]
            a+=1
        return a
3375. Minimum Operations to Make Array Values Equal to K
class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        hasX=0
        xMin=101
        for x in nums:
            hasX|=1<<x
            xMin=min(x, xMin)
        
        if xMin<k: return -1
        B=hasX.bit_count()
        return B-1 if xMin==k else B

2999. Count the Number of Powerful Integers
class Solution:
    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:
        s_start = str(start - 1)
        s_finish = str(finish)
        return self.count_powerful(s_finish, s, limit) - self.count_powerful(s_start, s, limit)
    
    def count_powerful(self, num: str, suffix: str, limit: int) -> int:
        if len(num) < len(suffix):
            return 0
        if len(num) == len(suffix):
            return 1 if num >= suffix else 0
        
        result = 0
        prefix_len = len(num) - len(suffix)
        
        for i in range(prefix_len):
            digit = int(num[i])

            if digit > limit:
                result += (limit + 1) ** (prefix_len - i)
                return result
            result += digit * (limit + 1) ** (prefix_len - i - 1)
        
        if num[-len(suffix):] >= suffix:
            result += 1        
        return result
2843. Count Symmetric Integers
class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        c = 0 
        for num in range(low, high + 1):
            s = str(num) 
            n = len(s)

            if n % 2 != 0:
                continue  
            half = n // 2
            left = sum(int(s[i]) for i in range(half))  
            right = sum(int(s[i]) for i in range(half, n))  

            if left == right:
                c += 1 

        return c
3272. Find the Count of Good Integers
class Solution:
    def countGoodIntegers(self, n: int, k: int) -> int:
        if n == 1:
            total = 0
            for i in range(1, 10):
                if i % k == 0:
                    total += 1
            return total
        fact = [1]
        for i in range(1, n + 1):
            fact.append(fact[-1] * i)
        seen = set()
        ans = 0
        for left in range(10 ** ((n - 1) // 2), 10 ** ((n + 1) //2)):
            l = str(left)
            r = l[::-1]
            if n % 2 == 1:
                r = r[1:]
            t = l + r
           
            if int(t) % k != 0:
                continue

            s = "".join(sorted(list(t)))
            if s in seen:
                continue
            seen.add(s)

            count = Counter(t)

            total = fact[n]
            for key in count.keys():
                total //= fact[count[key]]

            ans += total
            if count["0"] >= 1:
                total_non_zero = fact[n - 1]
                count["0"] -= 1
                for key in count.keys():
                    total_non_zero //= fact[count[key]]
                ans -= total_non_zero   

        return ans
1922. Count Good Numbers
class Solution:
    m=10**9+7
    def countGoodNumbers(self, n: int) -> int:
        even=(n+1)//2
        odd=n//2
        e=self.fun(5,even)
        o=self.fun(4,odd)
        return (e*o)%self.m

    def fun(self,a,b):
        r=1
        a%=self.m

        while b>0:
            if b%2==1:
                r=(r*a)%self.m
            a=(a*a)%self.m
            b//=2
        return r
1534. Count Good Triplets
class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        n = len(arr)
        count = 0
        for i in range(n - 2):
            ai = arr[i]
            for j in range(i + 1, n - 1):
                aj = arr[j]
                if abs(ai - aj) > a:
                    continue
                for k in range(j + 1, n):
                    ak = arr[k]
                    diff_jk = abs(aj - ak)
                    if diff_jk > b:
                        continue
                    if abs(ai - ak) <= c:
                        count += 1
        return count
2537. Count the Number of Good Subarrays

class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        n=len(nums)
        freq=defaultdict(int)
        ans, cnt, l=0, 0, 0
        for r,x in enumerate(nums):
            cnt+=freq[x]
            freq[x]+=1
            while cnt>=k:
                ans+=n-r
                freq[nums[l]]-=1
                cnt-=freq[nums[l]]
                l+=1
        return ans

2176. Count Equal and Divisible Pairs in an Array

class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        a=[[] for i in range(101)]
        c=0
        for j, x in enumerate(nums):
            for i in a[x]:
                c+=(i*j%k==0)
            a[x].append(j)
        return c
38. Count and Say
class Solution:
    def countAndSay(self, n: int) -> str:
        s="1"
        while n-1>0:
            curr=s[0]
            c=1
            ans=""
            for i in range(1,len(s)):
                if curr==s[i]:
                    c+=1
                else:
                    ans+=str(c)
                    ans+=curr
                    curr=s[i]
                    c=1
            ans+=str(c)
            ans+=curr
            s=ans
            n-=1
        print(s)
        return s

2563. Count the Number of Fair Pairs
from bisect import bisect_left, bisect_right

class Solution:
    def countFairPairs(self, v, lower, upper):
        v.sort()
        ans = 0
        for i in range(len(v) - 1):
            low = bisect_left(v, lower - v[i], i + 1)
            up = bisect_right(v, upper - v[i], i + 1)
            ans += up - low
        return ans
781. Rabbits in Forest

class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        answers.sort()
        a=0
        c=0
        for i in range(len(answers)):
            if answers[i]==0:
                a+=1
            elif i==0 or answers[i]!=answers[i-1] or c==0:
                a+=answers[i]+1
                c=answers[i]
            else:
                c-=1
        return a

2145. Count the Hidden Sequences
class Solution:
    def numberOfArrays(self, diff: List[int], lower: int, upper: int) -> int:
        return (K:=list(accumulate(diff, initial=0))) and max(0, upper-lower+1-max(K)+min(K))

2338. Count the Number of Ideal Arrays
from collections import Counter
from math import comb

class Solution:
    def idealArrays(self, length: int, max_value: int) -> int:
        MOD = 1_000_000_007
        total_ways = max_value
        frequency_map = {num: 1 for num in range(1, max_value + 1)}
        
        for array_size in range(1, length): 
            new_frequency = Counter()
            for base_value in frequency_map: 
                for multiplier in range(2, max_value // base_value + 1): 
                    combinations = comb(length - 1, array_size)
                    total_ways += combinations * frequency_map[base_value]
                    new_frequency[multiplier * base_value] += frequency_map[base_value]
            frequency_map = new_frequency
            total_ways %= MOD
        
        return total_ways

1399. Count Largest Group
class Solution:
    def countLargestGroup(self, n: int) -> int:
        freq=[0]*37
        maxF, sz=1, 1
        freq[1]=1
        for x in range(2, n+1):
            digit_sum, y=0, x
            while y>0:
                q, r=divmod(y, 10)
                digit_sum+=r
                y=q
            freq[digit_sum]+=1
            f=freq[digit_sum]
            if f==maxF: 
                sz+=1
            elif f>maxF:
                maxF=f
                sz=1
        return sz
2799. Count Complete Subarrays in an Array

from collections import defaultdict

class Solution:
    def countCompleteSubarrays(self, nums: List[int]) -> int:
        total_distinct = len(set(nums))
        count = defaultdict(int)
        left = res = 0

        for right in range(len(nums)):
            count[nums[right]] += 1
            while len(count) == total_distinct:
                res += len(nums) - right
                count[nums[left]] -= 1
                if count[nums[left]] == 0:
                    del count[nums[left]]
                left += 1
        return res
2444. Count Subarrays With Fixed Bounds

class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        total = 0
        last_invalid = last_min = last_max = -1

        for i, num in enumerate(nums):
            if num < minK or num > maxK:
                last_invalid = i
            if num == minK:
                last_min = i
            if num == maxK:
                last_max = i

            valid_start = min(last_min, last_max)
            total += max(0, valid_start - last_invalid)

        return total

3392. Count Subarrays of Length Three With a Condition
class Solution:
    def countSubarrays(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums) - 2):
            if (nums[i] + nums[i+2]) * 2 == nums[i+1]:
                count += 1
        return count

2302. Count Subarrays With Score Less Than K

class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        start = 0
        sum_ = 0
        count = 0
        
        for end in range(len(nums)):
            sum_ += nums[end]
            
            while sum_ * (end - start + 1) >= k:
                sum_ -= nums[start]
                start += 1
            
            count += (end - start + 1)
        
        return count
2962. Count Subarrays Where Max Element Appears at Least K Times

class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        max_element = max(nums)
        res = 0
        left = maxi_count = 0
        
        for right in range(len(nums)):
            if nums[right] == max_element:
                maxi_count += 1
            while maxi_count == k:
                res += len(nums) - right
                if nums[left] == max_element:
                    maxi_count -= 1
                left += 1
        
        return res

1295. Find Numbers with Even Number of Digits

class Solution:
    def findNumbers(self, nums: List[int]) -> int:
        c=0
        for i in nums:
            s=str(i)
            l=len(s)
            if l%2==0:
                c+=1
        return c
2071. Maximum Number of Tasks You Can Assign

class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int],pills: int, strength: int) -> int:

        def cannot_complete(numTasks: int, p = pills)-> bool:
            cnt = 0 
            jobs = deque()
            
            for i in range(numTasks - 1, -1, -1): 
                while cnt < numTasks:
                    if tasks[cnt] > workers[i] + strength: break
                    jobs.append(tasks[cnt])
                    cnt += 1
                
                if not jobs:
                    return True
                
                if workers[i] >= jobs[0]:
                    jobs.popleft()
                elif p > 0:
                    jobs.pop()
                    p -= 1
                else:
                    return True

            return False


        tasks.sort()
        workers.sort(reverse = True)
        n = min(len(tasks), len(workers)) + 1

        return bisect_left(range(n), True, key = cannot_complete) - 1
838. Push Dominoes

class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        dominoes = list(dominoes)
        n = len(dominoes)
        last_right = -1
        last_left = 0

        for i, d in enumerate(dominoes):
            if d == 'R':
                if last_right != -1:
                    for j in range(last_right + 1, i):
                        dominoes[j] = 'R'
                last_right = i
            elif d == 'L':
                if last_right != -1:
                    l, r = last_right + 1, i - 1
                    while l < r:
                        dominoes[l], dominoes[r] = 'R', 'L'
                        l += 1
                        r -= 1
                    last_right = -1
                else:
                    for j in range(last_left, i):
                        dominoes[j] = 'L'
                last_left = i

        if last_right != -1:
            for i in range(last_right + 1, n):
                dominoes[i] = 'R'

        return ''.join(dominoes)
1007. Minimum Domino Rotations For Equal Row

class Solution:
    def minDominoRotations(self, tops, bottoms):
        res = float('inf')
        for val in range(1, 7):
            top_swaps = bottom_swaps = 0
            valid = True
            for t, b in zip(tops, bottoms):
                if t != val and b != val:
                    valid = False
                    break
                if t != val:
                    top_swaps += 1
                if b != val:
                    bottom_swaps += 1
            if valid:
                res = min(res, top_swaps, bottom_swaps)
        return -1 if res == float('inf') else res
1128. Number of Equivalent Domino Pairs

class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        f=[0]*100
        c=0
        for i, j in dominoes:
            if i<j:
                x=10*i+j
            else:
                x=10*j+i
            c+=f[x]
            f[x]+=1
        return c
790. Domino and Tromino Tiling

class Solution:
    def numTilings(self, n: int) -> int:
        MOD = 10**9 + 7
        dp = [0] * (max(4, n + 1))
        dp[1], dp[2], dp[3] = 1, 2, 5
        for i in range(4, n + 1):
            dp[i] = (2 * dp[i - 1] + dp[i - 3]) % MOD
        return dp[n]
1920. Build Array from Permutation

class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        return [nums[nums[i]] for i in range(len(nums))]
3341. Find Minimum Time to Reach Last Room I

import heapq

class Solution:
    def minTimeToReach(self, moveTime):
        m, n = len(moveTime), len(moveTime[0])
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        heap = [(0, 0, 0)]  # time, row, col

        while heap:
            time, r, c = heapq.heappop(heap)
            if (r, c) == (m-1, n-1):
                return time
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n:
                    wait_time = max(time, moveTime[nr][nc]) + 1
                    if wait_time < dist[nr][nc]:
                        dist[nr][nc] = wait_time
                        heapq.heappush(heap, (wait_time, nr, nc))
        return -1

3342. Find Minimum Time to Reach Last Room II

import heapq

class Solution:
    def minTimeToReach(self, moveTime):
        n, m = len(moveTime), len(moveTime[0])
        vis = [[False] * m for _ in range(n)]
        heap = [(0, 0, 0, 0)]  # (time, moves, row, col)
        vis[0][0] = True
        dirs = [(0,1), (1,0), (-1,0), (0,-1)]

        while heap:
            time, moves, r, c = heapq.heappop(heap)
            if r == n - 1 and c == m - 1:
                return time
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < m and not vis[nr][nc]:
                    vis[nr][nc] = True
                    wait = max(time, moveTime[nr][nc])
                    travel_time = 1 if moves % 2 == 0 else 2
                    heapq.heappush(heap, (wait + travel_time, moves + 1, nr, nc))
        return -1
3343. Count Number of Balanced Permutations

MOD = 10**9 + 7

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        cnt = Counter(int(ch) for ch in num)
        total = sum(int(ch) for ch in num)

        if total % 2 != 0:
            return 0

        half_sum = total // 2
        n = len(num)
        even_count = n // 2
        odd_count = n - even_count

        @lru_cache(maxsize=None)
        def dfs(digit, odd, even, balance):
            if odd == 0 and even == 0 and balance == 0:
                return 1
            if digit < 0 or odd < 0 or even < 0 or balance < 0:
                return 0

            res = 0
            for j in range(0, cnt[digit] + 1):
                odd_used = j
                even_used = cnt[digit] - j
                if odd_used > odd or even_used > even:
                    continue
                comb_odd = comb(odd, odd_used)
                comb_even = comb(even, even_used)
                res += comb_odd * comb_even * dfs(
                    digit - 1,
                    odd - odd_used,
                    even - even_used,
                    balance - digit * odd_used
                )
                res %= MOD
            return res

        return dfs(9, odd_count, even_count, half_sum)
2918. Minimum Equal Sum of Two Arrays After Replacing Zeros

class Solution:
    def minSum(self, nums1, nums2):
        nums1_sum = sum(x if x != 0 else 1 for x in nums1)
        nums2_sum = sum(x if x != 0 else 1 for x in nums2)

        nums1_zeros = nums1.count(0)
        nums2_zeros = nums2.count(0)

        if (nums1_zeros == 0 and nums2_sum > nums1_sum) or \
           (nums2_zeros == 0 and nums1_sum > nums2_sum):
            return -1
        return max(nums1_sum, nums2_sum)
1550. Three Consecutive Odds

class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        for i in range(len(arr) - 2):
            if arr[i] % 2 + arr[i + 1] % 2 + arr[i + 2] % 2 == 3:
                return True
        return False
2094. Finding 3-Digit Even Numbers

class Solution:
    def findEvenNumbers(self, dig: List[int]) -> List[int]:        
        arr = []
        for i in range(100, 999):
            flag = True
            seen = Counter(dig)
            for s in str(i):
                if int(s) not in seen:
                    flag = False
                    break
                else:
                    seen[int(s)] -= 1
                    if seen[int(s)] == 0:
                        del seen[int(s)]
            if flag and i % 2 == 0:
                arr.append(i)
        
        return arr
3335. Total Characters in String After Transformations I

class Solution:
    def lengthAfterTransformations(self, s: str, t: int) -> int:
        l=1
        mod=10**9+7
        if  len(set(s))==1:
            l=len(s)
            s=s[0]
        def fn(chrs):
            b = [0]*26
            for i in chrs:
                x = ord(i) - ord('a')
                b[x] += 1
            return b
        def fn3(lst):
            b=[0]*26
            n = len(lst)
            ll=[]
            for i in range(n):
                if lst[i]>0:
                    ll.append((i, lst[i]))
            for p,i in ll:
                if p==25:
                    b[0]+=i%mod
                    b[1]+=i%mod
                else:
                    b[p+1]+=i
                b[p]=0 if b[p]-1<0 else b[p]
            return b
        b=fn(s)

        for i in range(t):
            b=fn3(b)
        
        return (sum(b)*l)%mod
3337. Total Characters in String After Transformations II

class Solution:
    def lengthAfterTransformations(self, s: str, t: int, nums: List[int]) -> int:
        mod = 10**9 + 7
        vector = [[0] * 26 for _ in range(26)]
        for c in range(26):
            num = nums[c]
            for j in range(1, num + 1):
                next_c = (c + j) % 26
                vector[c][next_c] += 1

        def matrix_multi(x, y):
            res = [[0] * 26 for _ in range(26)]
            for i in range(26):
                for j in range(26):
                    if x[i][j] == 0:
                        continue
                    for l in range(26):
                        res[i][l] = (res[i][l] + x[i][j] * y[j][l]) % mod
            return res

        def matrix_pol(m, n):
            total = [[1 if i == j else 0 for j in range(26)] for i in range(26)]
            while n > 0:
                if n % 2 == 1:
                    total = matrix_multi(total, m)
                m = matrix_multi(m, m)
                n //= 2
            return total
        compute = matrix_pol(vector, t)

        cnt = [0] * 26
        for c in s:
            cnt[ord(c) - ord('a')] += 1
            
        new_cnt =[0] * 26
        for i in range(26):
            for j in range(26):
                new_cnt[j] = (new_cnt[j] + cnt[i] * compute[i][j]) % mod
                         
        result = 0
        for x in new_cnt:
            result = (result + x) % mod
        return result
2900. Longest Unequal Adjacent Groups Subsequence I

class Solution:
    def getLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:
        res = [words[0]]
        lastBit = groups[0]
        for i in range(1, len(words)):
            if groups[i] != lastBit:
                res.append(words[i])
                lastBit ^= 1
                
        return res
2901. Longest Unequal Adjacent Groups Subsequence II

class Solution:
    def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:
        n = len(words)
        connections = {}
        maxs = {}
        result = []

        def HammingDistance(base, word):
            differences = 0
            
            if len(base) != len(word):
                return -1
            else:
                for i in range(len(word)):
                    if base[i] != word[i]: differences += 1
                    if differences > 2: return -1
            return differences

        for i in range(n):
            connections[i] = []
            for k in range(i, n):
                if groups[i] != groups[k] and HammingDistance(words[i], words[k]) == 1:
                    connections[i].append(k)
        
        for i in range(n - 1, -1, -1):
            maxs[i] = []

            for connection in connections[i]:
                if len(maxs[connection]) > len(maxs[i]):
                    maxs[i] = maxs[connection]
            
            maxs[i] = [words[i]] + maxs[i]
            if len(maxs[i]) > len(result):
                result = maxs[i]

        return result
75. Sort Colors

class Solution {
    public void sortColors(int[] nums) {
        int n=nums.length;
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                if(nums[i]>nums[j]){
                    int temp=nums[i];
                    nums[i]=nums[j];
                    nums[j]=temp;
                }
            }
        }
    }
}
1931. Painting a Grid With Three Different Colors

class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        from itertools import product
        from collections import defaultdict

        MOD = 10**9 + 7
        def is_valid(col):
            return all(col[i] != col[i + 1] for i in range(len(col) - 1))

        colors = [0, 1, 2]  
        valid_cols = []
        for col in product(colors, repeat=m):
            if is_valid(col):
                valid_cols.append(col)
        compatible = {}
        for c1 in valid_cols:
            compatible[c1] = []
            for c2 in valid_cols:
                if all(a != b for a, b in zip(c1, c2)):
                    compatible[c1].append(c2)
        dp = defaultdict(int)
        for col in valid_cols:
            dp[col] = 1
        for _ in range(1, n):
            new_dp = defaultdict(int)
            for col in valid_cols:
                for prev in compatible[col]:
                    new_dp[col] = (new_dp[col] + dp[prev]) % MOD
            dp = new_dp

        return sum(dp.values()) % MOD
3024. Type of Triangle

class Solution:
    def triangleType(self, nums: List[int]) -> str:
        nums.sort()
        if nums[2]>=nums[0]+nums[1]: return "none"
        if nums[0]==nums[2]: return "equilateral"
        if nums[0]==nums[1] or nums[1]==nums[2]: return "isosceles"
        return "scalene"
3355. Zero Array Transformation I

class Solution:
    def isZeroArray(self, nums, queries):
        n = len(nums)
        q = [0] * (n + 1)
        for start, end in queries:
            q[start] += 1
            if end + 1 < len(q):
                q[end + 1] -= 1
        for i in range(1, n):
            q[i] += q[i - 1]
        for i in range(n):
            if q[i] < nums[i]:
                return False
        return True
Set Matrix Zeroes

class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        rows = len(matrix)
        cols = len(matrix[0])

        first_row_has_zero = any(matrix[0][y] == 0 for y in range(cols))
        first_col_has_zero = any(matrix[x][0] == 0 for x in range(rows))

        for x in range(1, rows):
            for y in range(1, cols):
                if matrix[x][y] == 0:
                    matrix[x][0] = 0
                    matrix[0][y] = 0

        for x in range(1, rows):
            if matrix[x][0] == 0:
                for y in range(cols):
                    matrix[x][y] = 0

        for y in range(1, cols):
            if matrix[0][y] == 0:
                for x in range(rows):
                    matrix[x][y] = 0

        if first_row_has_zero:
            for y in range(cols):
                matrix[0][y] = 0

        if first_col_has_zero:
            for x in range(rows):
                matrix[x][0] = 0
3362. Zero Array Transformation III

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        intervals = sorted(queries, key=lambda x: x[0])
        idx = 0
        avail = []
        active = []
        chosen = 0

        for i in range(n):
            while active and active[0] < i:
                heapq.heappop(active)

            coverage = len(active)
            while idx < m and intervals[idx][0] <= i:
                l, r = intervals[idx]
                heapq.heappush(avail, (-r, r))
                idx += 1

            demand = nums[i]
            while coverage < demand:
                while avail and avail[0][1] < i:
                    heapq.heappop(avail)
                if not avail:
                    return -1
                _, r = heapq.heappop(avail)
                heapq.heappush(active, r)
                chosen += 1
                coverage += 1

        return m - chosen   
3068. Find the Maximum Sum of Node Values

class Solution:
    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
        n=len(nums)
        @cache
        def f(i, c):
            if i==n:
                if c==1: return -(1<<31)
                return 0
            x=nums[i]
            return max(x+f(i+1, c),(x^k)+f(i+1,1-c))
        return f(0, 0)
2942. Find Words Containing Character

class Solution:
    def findWordsContaining(self, words: List[str], x: str) -> List[int]:
        return [i for i, w in enumerate(words) if w.find(x)!=-1]
2131. Longest Palindrome by Concatenating Two Letter Words

class Solution:
    def longestPalindrome(self, words: List[str]) -> int:
        wordCount = Counter(words)
        length = 0
        hasMiddle = False
        
        for word in wordCount:
            reverseWord = word[::-1]
            
            if word == reverseWord:
                pairs = wordCount[word] // 2
                length += pairs * 4
                
                if wordCount[word] % 2 == 1 and not hasMiddle:
                    hasMiddle = True
                    length += 2
            
            elif word < reverseWord and reverseWord in wordCount:
                pairs = min(wordCount[word], wordCount[reverseWord])
                length += pairs * 4
        
        return length   
1857. Largest Color Value in a Directed Graph

class Solution:
    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:
        hashmap = collections.defaultdict(list)

        for u, v in edges:
            if u == v:
                return -1
            hashmap[u].append(v)

        visited = set()
        
        @cache
        def dfs(curr, target):
            result = 0
            for adj in hashmap[curr]:
                if adj in visited:
                    return float('inf')
                visited.add(adj)
                result = max(result, dfs(adj, target))
                visited.remove(adj)

            return result + 1 if colors[curr] == target else result

        max_path_value = 0
        for i in range(len(colors)):
            max_path_value = max(max_path_value, dfs(i, colors[i]))

        return -1 if max_path_value == float('inf') else max_path_value
2894. Divisible and Non-divisible Sums Difference

class Solution:
    def differenceOfSums(self, n: int, m: int) -> int:
        return n*(n+1)//2-m*(n//m)*(n//m+1)

3372. Maximize the Number of Target Nodes After Connecting Trees I

from collections import deque
from typing import List

class Solution:
    def maxTargetNodes(self, edges1: List[List[int]], edges2: List[List[int]], k: int) -> List[int]:
        def build_graph(edges):
            n = len(edges) + 1
            graph = [[] for _ in range(n)]
            for u, v in edges:
                graph[u].append(v)
                graph[v].append(u)
            return graph

        def bfs_count_max(graph, max_dist):
            n = len(graph)
            result = [0] * n
            for start in range(n):
                visited = [False] * n
                q = deque()
                q.append((start, 0))
                visited[start] = True
                count = 1
                while q:
                    node, dist = q.popleft()
                    if dist == max_dist:
                        continue
                    for neighbor in graph[node]:
                        if not visited[neighbor]:
                            visited[neighbor] = True
                            q.append((neighbor, dist + 1))
                            count += 1
                result[start] = count
            return result

        g1 = build_graph(edges1)
        g2 = build_graph(edges2)

        if k == 0:
            return [1] * len(g1)

        cnt1 = bfs_count_max(g1, k)
        cnt2 = bfs_count_max(g2, k - 1)
        max_cnt2 = max(cnt2)

        return [cnt + max_cnt2 for cnt in cnt1]
3373. Maximize the Number of Target Nodes After Connecting Trees II

class Solution:
    def maxTargetNodes(self, edges1: List[List[int]], edges2: List[List[int]]) -> List[int]:
        def find_even(edges: list, n : int) -> list:
            graph = [[] for _ in range(n)]
            queue = deque([(0, -1, True)])
            evens = [False] * n
            for u, v in edges:
                graph[u].append(v)
                graph[v].append(u)
            while queue:
                node, parent, is_even = queue.popleft()
                evens[node] = is_even
                for child in graph[node]:
                    if child == parent:
                        continue
                    queue.append((child, node, not is_even))
            return evens
        n1, n2 = len(edges1) + 1, len(edges2) + 1
        even1, even2 = find_even(edges1, n1), find_even(edges2, n2)
        total1, total2 = sum(even1), sum(even2)
        mx = max(total2, n2 - total2)
        ans = [mx + (total1 if even else n1 - total1) for even in even1]
        return ans
2359. Find Closest Node to Given Two Nodes

class Solution:
    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:
        n=len(edges)
        inf=1<<32
        dist1=[inf]*n
        dist2=[inf]*n
        def dfs(node, dist):
            d, i=0, node
            while i!=-1 and dist[i]==inf:
                dist[i]=d
                d+=1
                i=edges[i]
        dfs(node1, dist1)
        dfs(node2, dist2)
        minD, index=inf, -1
        for i in range(n):
            max12=max(dist1[i], dist2[i])
            if max12<minD: 
                minD=max12
                index=i
        return index
909. Snakes and Ladders

from collections import deque

class Solution:
    def snakesAndLadders(self, board):
        n = len(board)
        
        def get_pos(num):
            r, c = divmod(num - 1, n)
            if r % 2 == 0:
                return (n - 1 - r, c)
            return (n - 1 - r, n - 1 - c)

        visited = [False] * (n * n + 1)
        q = deque([1])
        visited[1] = True
        moves = 0

        while q:
            for _ in range(len(q)):
                curr = q.popleft()
                if curr == n * n:
                    return moves
                for i in range(1, 7):
                    nxt = curr + i
                    if nxt > n * n:
                        continue
                    r, c = get_pos(nxt)
                    if board[r][c] != -1:
                        nxt = board[r][c]
                    if not visited[nxt]:
                        visited[nxt] = True
                        q.append(nxt)
            moves += 1

        return -1
2929. Distribute Candies Among Children II

class Solution:
    def distributeCandies(self, n: int, limit: int) -> int:
        def H3(n):
            return 0 if n<0 else (n+2)*(n+1)//2
        return H3(n)-3*H3(n-limit-1)+3*H3(n-2*(limit+1))-H3(n-3*(limit+1))
135. Candy

class Solution:
    def candy(self, a: List[int]) -> int:
        f = lambda a:[*accumulate(map(lt,a,a[1:]),lambda q,p:q*p+1,initial=1)]
        return sum(map(max,f(a),f(a[::-1])[::-1]))
1298. Maximum Candies You Can Get from Boxes

class Solution:
    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:
        def dfs(i):
            ans=candies[i]
            status[i]=0
            for k in keys[i]:
                status[k]|=1
                if status[k]==3: ans+=dfs(k)
            for j in containedBoxes[i]:
                status[j]|=2
                if status[j]==3: ans+=dfs(j)
            return ans
        cnt=0
        for i in initialBoxes:
            status[i]|=2
            if status[i]==3:
                cnt+=dfs(i)
        return cnt
3403. Find the Lexicographically Largest String From the Box I

class Solution:
    def answerString(self, word: str, n: int) -> str:
        x=len(word)-n+1 
        if n==1: 
            return word
        return max(word[i:i+x] for i in range(len(word)))
1061. Lexicographically Smallest Equivalent String

class Solution:
    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:
        uf = ascii_lowercase
        for i,j in sorted({tuple(sorted(map(ord,p))) for p in zip(s1,s2)}):
            uf = uf.replace(*sorted((uf[i-97],uf[j-97]))[::-1]) 

        return ''.join(uf[ord(c)-97] for c in baseStr)
2434. Using a Robot to Print the Lexicographically Smallest String

class Solution:
    def robotWithString(self, s: str) -> str:
        n = len(s)
        result = []
        stack = []
        min_suf = [''] * n
        min_suf[-1] = s[-1]
        for i in range(n - 2, -1, -1):
            min_suf[i] = min(s[i], min_suf[i + 1])

        for i in range(n):
            stack.append(s[i])

            while stack and (i == n - 1 or stack[-1] <= min_suf[i + 1]):
                result.append(stack.pop())

        return ''.join(result)
3170. Lexicographically Minimum String After Removing Stars

class Solution:
    def clearStars(self, s: str) -> str:
        h = []
        stacks = [[] for _ in range(26)]

        for i, c in enumerate(s):
            if c == "*":
                while h and not stacks[h[0]]:
                    heapq.heappop(h)
                if h:
                    stacks[h[0]].pop()
                    if not stacks[h[0]]:
                        heapq.heappop(h)
            else:
                x = ord(c) - ord('a')
                if not stacks[x]:
                    heapq.heappush(h, x)
                stacks[x].append(i)

        result = []
        indices = []
        for stack in stacks:
            indices.extend(stack)
    
        indices.sort()
        return ''.join(s[i] for i in indices)
386. Lexicographical Numbers

class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        l=[]
        c=1
        while len(l)<n:
            l.append(c)
            if c*10<=n:
                c*=10
            else:
                while c%10==9 or c==n:
                    c//=10
                c+=1
        return l
440. K-th Smallest in Lexicographical Order

class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        def count(curr):
            next, cnt = curr + 1, 0
            while curr <= n:
                cnt += min(n - curr + 1, next - curr)
                next, curr = next * 10, curr * 10
            return cnt

        curr = 1
        k -= 1
        while k:
            cnt = count(curr)
            if k >= cnt:
                k -= cnt
                curr += 1
            else:
                k -= 1
                curr *= 10
        return curr

3442. Maximum Difference Between Even and Odd Frequency I

class Solution:
    def maxDifference(self, s: str) -> int:
        freq=Counter(s)
        oddEven=[-100, 0]
        for f in freq.values():
            f=-f if (f&1)==0 else f
            oddEven[f&1]=max(f, oddEven[f&1])
        return sum(oddEven)
3445. Maximum Difference Between Even and Odd Frequency II

class Solution:
    def maxDifference(self, s: str, k: int) -> int:
        n = len(s)
        res = float('-inf')
        for a in '01234':
            for b in '01234':
                if a == b:
                    continue
                arr = [1 if c == a else (-1 if c == b else 0) for c in s]
                aa = [1 if c == a else 0 for c in s]
                bb = [1 if c == b else 0 for c in s]
                pa = [0] * (n + 1)
                pb = [0] * (n + 1)
                p = [0] * (n + 1)
                for i in range(n):
                    p[i + 1] = p[i] + arr[i]
                    pa[i + 1] = pa[i] + aa[i]
                    pb[i + 1] = pb[i] + bb[i]
                mn = [[float('inf'), float('inf')], [float('inf'), float('inf')]]
                i = 0
                for j in range(n + 1):
                    while j - i >= k and pa[j] - pa[i] > 0 and pb[j] - pb[i] > 0:
                        mn[pa[i] % 2][pb[i] % 2] = min(mn[pa[i] % 2][pb[i] % 2], p[i])
                        i += 1
                    res = max(res, p[j] - mn[1 - (pa[j] % 2)][pb[j] % 2])
        return res
3423. Maximum Difference Between Adjacent Elements in a Circular Array

class Solution:
    def maxAdjacentDistance(self, nums: List[int]) -> int:
        return max(abs(nums[0]-nums[-1]), max(abs(x-y) for x, y in pairwise(nums)))
2616. Minimize the Maximum Difference of Pairs

class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        nums.sort()
        n = len(nums)
        def pairing(diff):
            count = i = 0
            while i < n - 1 and count < p:
                if nums[i + 1] - nums[i] <= diff:
                    count += 1
                    i += 2
                else:
                    i += 1
            return count >= p

        l, r = 0, nums[-1] - nums[0]
        while l < r:
            mid = (l + r) // 2
            if pairing(mid):
                r = mid
            else:
                l = mid + 1
        return l
2566. Maximum Difference by Remapping a Digit

class Solution:
    def minMaxDifference(self, num: int) -> int:
        T=pow(10, int(log10(num)))
        seeA, seeB= False, False
        a, b, x, y=-1, -1, 0, 0
        t=T
        while t>=1:
            d, num=divmod(num, t)
            if not seeA and d!=9:
                a=d
                seeA=True
                x+=9*t
            elif seeA and d==a:
                x+=9*t
            else:
                x+=d*t
            if not seeB and d!=0:
                b=d
                seeB=True
            elif d!=b:
                y+=d*t
            t//=10
        return x-y
1432. Max Difference You Can Get From Changing an Integer

class Solution:
    def maxDiff(self, num: int) -> int:
        mx,mn=str(num),str(num)
        
        j=0
        while mx[j]=='9' and j<len(mx)-1:
            j+=1
        mx=mx.replace(mx[j],'9')

        for i in range(len(mn)):
            if i==0:
                if mn[i]!='1':
                    mn=mn.replace(mn[i],'1')
                    break
            else:
                if mn[i]!='0' and mn[i]!=mn[0]:
                    mn=mn.replace(mn[i],'0')
                    break

        return int(mx)-int(mn)
2016. Maximum Difference Between Increasing Elements

class Solution:
    def maximumDifference(self, nums: List[int]) -> int:
        a, n=10**9, len(nums)
        b=-1
        for x in nums:
            if x<=a:
                a=x
            else:
                b=max(b, x-a)
        return b
3405. Count the Number of Arrays with K Matching Adjacent Elements

mx = 10**5 + 10
mod = 10**9 + 7
f = [1] + [0] * mx
g = [1] + [0] * mx

for i in range(1, mx):
    f[i] = f[i - 1] * i % mod
    g[i] = pow(f[i], mod - 2, mod)


def comb(m: int, n: int) -> int:
    return f[m] * g[n] * g[m - n] % mod


class Solution:
    def countGoodArrays(self, n: int, m: int, k: int) -> int:
        return comb(n - 1, k) * m * pow(m - 1, n - k - 1, mod) % mod
2966. Divide Array Into Arrays With Max Difference

class Solution:
    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:
        l=[] 
        n=len(nums)
        nums.sort() 
        for i in range(0,n-2,3): 
            if nums[i+2]-nums[i]>k:
                return [] 
            l.append(nums[i:i+3]) 
        return l 
2294. Partition Array Such That Maximum Difference Is K

class Solution:
    def partitionArray(self, a: List[int], k: int) -> int:
        return len({*accumulate(sorted(a),lambda q,v:(q,v)[v-q>k])})
3443. Maximum Manhattan Distance After K Changes

class Solution:
    def maxDistance(self, s: str, k: int) -> int:
        x,y,ans=0,0,0
        for idx,ch in enumerate(s):
            if ch=='N': y+=1
            if ch=='S': y-=1
            if ch=='W': x-=1
            if ch=='E': x+=1
            ans=max(ans,min(abs(x)+abs(y)+2*k,idx+1))
        return ans
3085. Minimum Deletions to Make String K-Special

class Solution:
    def minimumDeletions(self, word: str, k: int) -> int:
        c= Counter(word)
        x = float('inf')
        for i in c.values():
            r= 0
            for j in c.values():
                if j < i:
                    r+= j
                elif j > i + k:
                    r+= j - (i + k)
            x= min(r, x)
        return x
2138. Divide a String Into Groups of Size k

class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        while len(s) % k:
            s += fill
        r= []
        for i in range(0, len(s), k):
            r.append(s[i:i+k])
        return r
2081. Sum of k-Mirror Numbers

class Solution:

    def isKPalindrome(self, x: int, base: int) -> bool:
        digits = []
        while x > 0:
            digits.append(x % base)
            x //= base
        return digits == digits[::-1]

    def generatePalindromes(self, length: int) -> List[int]:
        result = []
        if length == 1:
            for i in range(1, 10):
                result.append(i)
            return result

        half = 10 ** ((length + 1) // 2)
        start = 10 ** ((length - 1) // 2)
        for i in range(start, half):
            s = str(i)
            if length % 2 == 0:
                p = s + s[::-1]
            else:
                p = s + s[-2::-1]
            result.append(int(p))
        return result

    def kMirror(self, k: int, n: int) -> int:
        result = []
        length = 1
        while len(result) < n:
            for p in self.generatePalindromes(length):
                if self.isKPalindrome(p, k):
                    result.append(p)
                    if len(result) == n:
                        return sum(result)
            length += 1
        return sum(result)
2200. Find All K-Distant Indices in an Array

class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        n=len(nums)
        a=[]
        l=0
        for i, x in enumerate(nums):
            if x==key:
                z=min(n-1, i+k)
                l=max(l, i-k)
                while l<=z:
                    a.append(l)
                    l+=1
        return a
2040. Kth Smallest Product of Two Sorted Arrays

class Solution:
    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
        def pair(x):
            count = 0
            for n1 in nums1:
                if n1 > 0:
                    count += bisect.bisect_right(nums2, x // n1)
                elif n1 < 0:
                    count += len(nums2) - bisect_left(nums2, ceil(x / n1))
                elif x >= 0:
                    count += len(nums2)
            return count

        low = -10**10 - 1
        high = 10**10 + 1
        while low + 1 < high:
            mid = (low + high) // 2
            if pair(mid) >= k:
                high = mid
            else:
                low = mid
        return low + 1
2311. Longest Binary Subsequence Less Than or Equal to K

class Solution:
    def longestSubsequence(self, s: str, k: int) -> int:
        n = len(s)
        z = s.count('0')
        o= 0
        a= 0
        p= 1

        for i in range(n - 1, -1, -1):
            if s[i] == '1':
                if a+ p > k:
                    continue
                a+= p
                o += 1
            p<<= 1
            if p> k:
                break

        return z + o
class Solution:
    def isKRepeatedSubsequence(self, s: str, pattern: str, k: int) -> bool:
        pos = matched = 0
        m = len(pattern)
        for ch in s:
            if ch == pattern[pos]:
                pos += 1
                if pos == m:
                    pos = 0
                    matched += 1
                    if matched == k:
                        return True
        return False
2014. Longest Subsequence Repeated k Times

    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        freq = [0]*26
        for ch in s:
            freq[ord(ch)-97] += 1
        candidates = [chr(i+97) for i in range(25, -1, -1) if freq[i] >= k]

        q = deque(candidates)
        ans = ""

        while q:
            curr = q.popleft()
            if len(curr) > len(ans) or (len(curr) == len(ans) and curr > ans):
                if self.isKRepeatedSubsequence(s, curr, k):
                    ans = curr
            if len(curr) == 7:
                continue
            for ch in candidates:
                nxt = curr + ch
                if self.isKRepeatedSubsequence(s, nxt, k):
                    q.append(nxt)
        return ans
2099. Find Subsequence of Length K With the Largest Sum

class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        a= [(j, i) for i, j in enumerate(nums)]
        a.sort(key=lambda x: -x[0])
        t = sorted(a[:k], key=lambda x: x[1])
        return [j for j, _ in t]
1498. Number of Subsequences That Satisfy the Given Sum Condition

class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        m= 10 ** 9 + 7
        a = 0
        nums.sort()
        for i, n in enumerate(nums):
            if 2 * n > target:
                break
            j = bisect.bisect(nums, target - n, lo=i)
            a += pow(2, j - i - 1, m)
        return a % m
594. Longest Harmonious Subsequence

class Solution:
    def findLHS(self, nums: List[int]) -> int:
        x = Counter(nums)
        return max(
            0 if x[num + 1] == 0 else i + x[num + 1]
            for num, i
            in x.items()
        )
3330. Find the Original Typed String I

class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1         # flawless case
        i, n = 0, len(word)

        while i < n:
            j = i
            while j < n and word[j] == word[i]:
                j += 1              # walk to block end
            ans += (j - i - 1)      # add (L1) extra originals
            i = j                   # jump to next block
        return ans
3333. Find the Original Typed String II

class Solution:
    MOD = 10**9 + 7

    def possibleStringCount(self, word: str, k: int) -> int:
        if not word:
            return 0

        groups = []
        count = 1
        for i in range(1, len(word)):
            if word[i] == word[i - 1]:
                count += 1
            else:
                groups.append(count)
                count = 1
        groups.append(count)

        total = 1
        for num in groups:
            total = (total * num) % self.MOD

        if k <= len(groups):
            return total

        dp = [0] * k
        dp[0] = 1

        for num in groups:
            new_dp = [0] * k
            sum_val = 0
            for s in range(k):
                if s > 0:
                    sum_val = (sum_val + dp[s - 1]) % self.MOD
                if s > num:
                    sum_val = (sum_val - dp[s - num - 1] + self.MOD) % self.MOD
                new_dp[s] = sum_val
            dp = new_dp

        invalid = sum(dp[len(groups):k]) % self.MOD
        return (total - invalid + self.MOD) % self.MOD
3304. Find the K-th Character in String Game I

class Solution:
    def kthCharacter(self, k: int) -> str:
        x= ['a']
        while len(x) < k:
            size = len(x)
            for i in range(size):
                a = chr(ord('a') + ((ord(x[i]) - ord('a') + 1) % 26))
                x.append(a)
        return x[k - 1]
3307. Find the K-th Character in String Game II

class Solution:
    def kthCharacter(self, k: int, operations: List[int]) -> str:
        c= 0
        n = len(operations)
        length = pow(2, n-1)
        for i in range(n-1, -1, -1):
            if k > length:
                k -= length
                if operations[i] == 1:
                    c+= 1
            length //= 2
        return chr(ord('a') + (c % 26))
1394. Find Lucky Integer in an Array

class Solution:
    def findLucky(self, arr: List[int]) -> int:
        return max((a for a, i in Counter(arr).items() if a==i), default=-1)
Finding Pairs With a Certain Sum

class FindSumPairs:
    def __init__(self, nums1: List[int], nums2: List[int]):
        self.nums1 = nums1
        self.nums2 = nums2
        self.freq = Counter(nums2)

    def add(self, index: int, val: int) -> None:
        self.freq[self.nums2[index]] -= 1  # Remove old one
        self.nums2[index] += val
        self.freq[self.nums2[index]] += 1  # Count new one

    def count(self, tot: int) -> int:
        ans = 0
        for a in self.nums1:  
            ans += self.freq[tot - a]  # a + b = tot -> b = tot - a
        return ans
1353. Maximum Number of Events That Can Be Attended

import heapq
class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        events.sort(key=lambda x:x[0])
        heap_list = []
        event_attended = 0
        max_day = max([i[1] for i in events])
        min_day = min([i[0] for i in events])
        length = len(events)
        j=0
        print(max_day,min_day)
        for i in range(min_day,max_day+1):
            
            while j<length and events[j][0]<=i:
                end_tmp = events[j][1]
                heapq.heappush(heap_list,end_tmp)
                j+=1

            while heap_list and heap_list[0]<i:
                    heapq.heappop(heap_list)

            if heap_list:
                heapq.heappop(heap_list)
                event_attended+=1
        return event_attended
1751. Maximum Number of Events That Can Be Attended II

import bisect

class Solution:
    def __init__(self):
        self.events = []
    @cache
    def solve(self, i, k):
        if i >= len(self.events): 
            return 0
        if k <= 0: 
            return 0
        s, e, v = self.events[i]
        j = bisect.bisect(self.events, [e+1])
        return max(v + self.solve(j, k - 1), self.solve(i + 1, k))

    def maxValue(self, events: List[List[int]], k: int) -> int:
        events.sort()  
        self.events = events
        return self.solve(0, k)
3439. Reschedule Meetings for Maximum Free Time I

class Solution:
    def maxFreeTime(self, eventTime: int, k: int, startTime: List[int], endTime: List[int]) -> int:
        n, busy=len(startTime), 0
        for i in range(k):
            busy+=endTime[i]-startTime[i] 

        if n==k: return eventTime-busy

        ans=startTime[k]-busy

        l=0
        for r in range(k, n):
            busy+=(endTime[r]-startTime[r])-(endTime[l]-startTime[l])
            end=eventTime if r==n-1 else startTime[r+1]
            start=endTime[l]
            ans=max(ans, end-start-busy)
            l+=1
        return ans
3440. Reschedule Meetings for Maximum Free Time II

class Solution:
    def maxFreeTime(self, eventTime: int, startTime: List[int], endTime: List[int]) -> int:
        n = len(startTime)
        gaps = [startTime[0]] + [startTime[i] - endTime[i-1] for i in range(1, n)] + [eventTime - endTime[-1]]
        dur = [endTime[i] - startTime[i] for i in range(n)]
        initial_max = max(gaps)
        v1 = v2 = v3 = -1
        c1 = c2 = c3 = 0
        for g in gaps:
            if g > v1:
                v3, c3 = v2, c2
                v2, c2 = v1, c1
                v1, c1 = g, 1
            elif g == v1:
                c1 += 1
            elif g > v2:
                v3, c3 = v2, c2
                v2, c2 = g, 1
            elif g == v2:
                c2 += 1
            elif g > v3:
                v3, c3 = g, 1
            elif g == v3:
                c3 += 1
        res = initial_max
        for k in range(n):
            a, b = gaps[k], gaps[k+1]
            cnt1 = (a == v1) + (b == v1)
            if cnt1 < c1:
                max_other = v1
            else:
                cnt2 = (a == v2) + (b == v2)
                if cnt2 < c2:
                    max_other = v2
                else:
                    max_other = v3
            m = a + dur[k] + b
            if max_other >= dur[k]:
                ans_k = m if m > max_other else max_other
            else:
                ans_k = m - dur[k]
            if ans_k > res:
                res = ans_k
        return res
2402. Meeting Rooms III

class Solution:
    def mostBooked(self, n: int, m: List[List[int]]) -> int:
        r, c = [0]*n, [0]*n # rooms, counter
        for s, e in sorted(m):
            found = 0
            for i,f in enumerate(r):
                if f <= s:
                    r[i] = e
                    c[i] += 1
                    found = 1
                    break

            if not found:
                q = r.index(min(r))
                r[q] += e-s
                c[q] += 1

        return c.index(max(c))
1900. The Earliest and Latest Rounds Where Players Compete

class Solution:
    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:
        def dp(l, r, k):
            if l == r:  return (1, 1)
            if l > r:   return dp(r, l, k)
            a, b = inf, -inf
            for i in range(1, l + 1):
                for j in range(l - i + 1, r - i + 1):
                    s = i + j
                    if l + r - k // 2 <= s <= (k + 1) // 2:
                        x, y = dp(i, j, (k + 1) // 2)
                        if x + 1 < a: a = x + 1
                        if y + 1 > b: b = y + 1
            return (a, b)

        return list(dp(firstPlayer, n - secondPlayer + 1, n))
2410. Maximum Matching of Players With Trainers

class Solution:
    def matchPlayersAndTrainers(self, players: list[int], trainers: list[int]) -> int:
        players.sort()
        trainers.sort()
        count = 0
        i = j = 0

        while i < len(players) and j < len(trainers):
            if players[i] <= trainers[j]:
                count += 1
                i += 1
                j += 1
            else:
                j += 1

        return count
1290. Convert Binary Number in a Linked List to Integer

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        a = 0
        while head: 
            a = 2*a + head.val 
            head = head.next 
        return a 
3136. Valid Word

class Solution:
    def isValid(self, word: str) -> bool:
        n=len(word)
        if n<3: return False
        vowels=1|(1<<(ord('e')-97))|(1<<(ord('o')-97))|(1<<(ord('i')-97))|(1<<(ord('u')-97))
        v=0
        for c in word:
            if  not (c.isalpha() or c.isdigit()): return False
            if c.isalpha():
                i=ord(c)-97 if ord(c)>=97 else ord(c)-65
                v|=(1<<((vowels>>i)&1))
        return v==3

3201. Find the Maximum Length of Valid Subsequence I
class Solution:
    def maximumLength(self, nums: List[int]) -> int:
        even=0
        odd=0
        c = 1
        for i in range(len(nums)):
            if nums[i] % 2 == 0:
                even += 1
            else:
                odd += 1
            if i > 0 and nums[i] % 2 != nums[i-1] % 2:
                c+= 1    
        return max(c,even,odd)
Find the Maximum Length of Valid Subsequence II

class Solution:
    def maximumLength(self, a: List[int], k: int) -> int:
        x = Counter()
        for p in product((i%k for i in a),range(k)):
            x[p] = x[p[::-1]]+1

        return max(x.values())

2163. Minimum Difference in Sums After Removal of Elements
class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n=len(nums)//3
        diff=[0]*(n+1)
        heapify(pqL:=[-x for x in nums[:n]])
        heapify(pqR:=nums[2*n:])
        Sum=sum(nums[:n])
        ans=Sum
        for i in range(n, 2*n+1):
            diff[i-n]=Sum
            x=nums[i]
            if x>=-pqL[0]: continue
            Sum+=x+pqL[0]
            heapreplace(pqL, -x)
        Sum=sum(nums[2*n:])
        ans-=Sum
        for i in range(2*n-1, n-2, -1):
            diff[i-n+1]-=Sum
            ans=min(ans, diff[i-n+1])
            x=nums[i]
            if x<=pqR[0]: continue
            Sum+=x-pqR[0]
            heapreplace(pqR, x)
        return ans

1233. Remove Sub-Folders from the Filesystem
class Folder:
    def __init__(self):
        self.children = {} 
        self.end = False 

class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        root = Folder()

        res_paths = []
        folder.sort()

        for path in folder:
            tokens = path.split("/")
            is_subfolder = False
            curr = root

            for token in tokens:
                if curr.end:
                    is_subfolder = True
                    break
                if token not in curr.children:
                    curr.children[token] = Folder()
                curr = curr.children[token]
            
            if not is_subfolder:
                curr.end = True
                res_paths.append(path)
        
        return res_paths

1948. Delete Duplicate Folders in System
from collections import defaultdict

class Node:
    def __init__(self, name):
        self.name = name
        self.children = {}
        self.signature = ""

class Solution:
    def deleteDuplicateFolder(self, paths):
        root = Node("")
        for path in paths:
            node = root
            for folder in path:
                if folder not in node.children:
                    node.children[folder] = Node(folder)
                node = node.children[folder]
        
        signature_count = defaultdict(int)
        
        def dfs(node):
            if not node.children:
                node.signature = ""
                return ""
            child_signatures = []
            for name, child in sorted(node.children.items()):
                child_signature = dfs(child)
                child_signatures.append(f"{name}({child_signature})")
            node.signature = "".join(child_signatures)
            signature_count[node.signature] += 1
            return node.signature
        
        dfs(root)
        
        result = []
        current_path = []
        
        def dfs2(node):
            if node.children and signature_count[node.signature] >= 2:
                return
            current_path.append(node.name)
            result.append(current_path.copy())
            for name, child in sorted(node.children.items()):
                dfs2(child)
            current_path.pop()
        
        for name, child in sorted(root.children.items()):
            dfs2(child)
        
        return result

1957. Delete Characters to Make Fancy String
class Solution:
    def makeFancyString(self, s: str) -> str:
        l=[]
        c=1
        for i in range(len(s)):
            if i > 0 and s[i] == s[i - 1]:
                c+=1
            else:
                c=1
            if c<=2:
                l.append(s[i])
        return ''.join(l)

1695. Maximum Erasure Value
class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        counter=defaultdict(int) 
        res=i=tot=0
		
        for j in range(len(nums)):
            x=nums[j]   
            tot+=x
            counter[x]+=1
            while i < j and counter[x]>1: 
                counter[nums[i]]-=1
                tot-=nums[i]
                i+=1
            
            res=max(res, tot)            
        return res

1717. Maximum Score From Removing Substrings
class Solution:
    def maximumGain(self, s: str, x: int, y: int) -> int:
        r = 0
        for i,t in sorted(((x,'ab'),(y,'ba')))[::-1]:
            st = []
            for ch in s:
                if st and st[-1]+ch == t:
                    r += i
                    st.pop()
                else:
                    st.append(ch)
        
            s = st

        return r

2322. Minimum Score After Removals on a Tree
class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        def dfs(i: int,fa: int) -> int:
            res = nums[i]
            for j in g[i]:
                if j != fa:
                    res ^= dfs(j, i)
            return res

        def dfs2(i: int, fa: int) -> int:
            nonlocal s, s1, ans
            res = nums[i]
            for j in g[i]:
                if j != fa:
                    s2 = dfs2(j,i)
                    res ^= s2
                    mx = max(s ^ s1,s2,s1 ^ s2)
                    mn = min(s ^ s1,s2,s1 ^ s2)
                    ans = min(ans, mx - mn)
            return res

        g = defaultdict(list)
        for a,b in edges:
            g[a].append(b)
            g[b].append(a) 
        s = reduce(lambda x,y : x ^ y, nums)
        n = len(nums)
        ans = inf
        for i in range(n):
            for j in g[i]:
                s1 = dfs(i,j)
                dfs2(i,j)
        return ans  

3487. Maximum Unique Subarray Sum After Deletion
class Solution:
    def maxSum(self, nums: List[int]) -> int:
        c=0
        for i in set(nums) :
            if i>0:
                c+=i
        if c==0:
            return max(nums)
        return c

3480. Maximize Subarrays After Removing One Conflicting Pair
class Solution:
    def maxSubarrays(self, N: int, A: List[List[int]]) -> int:
        right = [[] for _ in range(N + 1)]
        for a, b in A:
            right[max(a, b)].append(min(a, b))
        
        ans = 0
        left = [0, 0]
        imp = [0] * (N + 1)
        for r in range(1, N + 1):
            for l in right[r]:
                left = max(left, [l, left[0]], [left[0], l])
            ans += r - left[0]
            imp[left[0]] += left[0] - left[1]
        
        return ans + max(imp)

2210. Count Hills and Valleys in an Array
class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        n, prev, cnt=len(nums), nums[0], 0
        diff=[0, 0]
        i=0
        while i<n:
            while i<n and prev==nums[i]: i+=1
            if i==n: break
            bigger=1 if nums[i]>prev else 0
            diff[bigger]=1
            cnt+=diff[bigger] and diff[1-bigger]
            diff[1-bigger]=0
            prev=nums[i]
            i+=1
        return cnt

2044. Count Number of Maximum Bitwise-OR Subsets
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        n = len(nums)
        m = 0
        for num in nums:
            m |= num
        
        c = 0
        t = 1 << n 
        for mask in range(1, t): 
            curr_or = 0
            for i in range(n):
                if (mask & (1 << i)) != 0:
                    curr_or |= nums[i]
            if curr_or == m:
                c += 1
        return c

2411. Smallest Subarrays With Maximum Bitwise OR
class Solution:
    def smallestSubarrays(self, nums: list[int]) -> list[int]:
        l = len(nums)
        a = [0] * l
        for i in range(l):
            x = nums[i]
            a[i] = 1
            j = i - 1
            while j >= 0 and nums[j] | x != nums[j]:
                a[j] = i - j + 1
                nums[j] |= x
                j -= 1
        return a

2419. Longest Subarray With Maximum Bitwise AND
class Solution(object):
    def longestSubarray(self, nums):
        a, c = 0, 0
        
        l = max(nums)
        for i in nums:
            if i == l:
                c += 1
            else:
                c = 0
            a = max(a, c)
        return a
898. Bitwise ORs of Subarrays
class Solution:
    def subarrayBitwiseORs(self, A: List[int]) -> int:
        s = set(A)
        t = set()
        t.add(A[0])
        for i in A[1:]:
            temp = set()
            for j in t:
                temp.add(i | j)
                s.add(i | j)
            t = temp
            t.add(i)

        return len(s)

118. Pascal's Triangle
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return []
        if numRows == 1:
            return [[1]]
        
        prevRows = self.generate(numRows - 1)
        newRow = [1] * numRows
        
        for i in range(1, numRows - 1):
            newRow[i] = prevRows[-1][i - 1] + prevRows[-1][i]
        
        prevRows.append(newRow)
        return prevRows

2561. Rearranging Fruits
class Solution:
    def minCost(self, basket1: List[int], basket2: List[int]) -> int:
        cnt = Counter(basket1)
        for x in basket2: cnt[x] -= 1
        last = []
        for k, v in cnt.items():
            if v % 2 != 0:
                return -1
            last += [k] * abs(v // 2)
        minx = min(basket1 + basket2)
        last.sort()
        return sum(min(2*minx, x) for x in last[0:len(last)//2])

2106. Maximum Fruits Harvested After at Most K Steps
class Solution:
    def maxTotalFruits(self, fruits, startPos: int, k: int) -> int:
        left = total = res = 0
        for right in range(len(fruits)):
            total += fruits[right][1]
            while left <= right and min(
                abs(startPos - fruits[left][0]) + fruits[right][0] - fruits[left][0],
                abs(startPos - fruits[right][0]) + fruits[right][0] - fruits[left][0]
            ) > k:
                total -= fruits[left][1]
                left += 1
            res = max(res, total)
        return res

904. Fruit Into Baskets
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        dic = {}
        res = 0
        wstart = 0
        curr = 0
        for wend in range(len(fruits)):
            fruit = fruits[wend]
            if fruit not in dic:
                dic[fruit] = 0
            dic[fruit] += 1
            while len(dic) > 2 and wstart < wend:
                rfruit = fruits[wstart]
                dic[rfruit] -= 1
                if dic[rfruit] == 0:
                    del dic[rfruit]
                wstart += 1
            res = max(wend-wstart+1, res)
            
        return res

3477. Fruits Into Baskets II
class Solution:
    def numOfUnplacedFruits(self, fruits: list[int], baskets: list[int]) -> int:
        n = len(fruits)
        alloted = 0
        for i in range(n):
            for j in range(n):
                if fruits[i] <= baskets[j]:
                    baskets[j] = -1 
                    alloted += 1
                    break
        return n - alloted

3479. Fruits Into Baskets III
class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        n = len(baskets)
        N = 1
        while N <= n:
            N <<= 1
        
        segTree = [0] * (2 * N)
        
        for i in range(n):
            segTree[N + i] = baskets[i]
        
        for i in range(N - 1, 0, -1):
            segTree[i] = max(segTree[2 * i], segTree[2 * i + 1])
        
        count = 0
        for fruit in fruits:
            index = 1
            if segTree[index] < fruit:
                count += 1
                continue
            
            while index < N:
                if segTree[2 * index] >= fruit:
                    index = 2 * index
                else:
                    index = 2 * index + 1
            
            segTree[index] = -1
            while index > 1:
                index //= 2
                segTree[index] = max(segTree[2 * index], segTree[2 * index + 1])
        
        return count

3363. Find the Maximum Number of Fruits Collected
class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        total = sum(fruits[i][i] for i in range(n))

        right_path = [0] * 3
        right_path[0] = fruits[0][n - 1]

        bottom_path = [0] * 3
        bottom_path[0] = fruits[n - 1][0]

        window = 2

        for step in range(1, n - 1):
            new_right = [0] * (window + 2)
            new_bottom = [0] * (window + 2)

            for dist in range(window):
                left = right_path[dist - 1] if dist - 1 >= 0 else 0
                mid = right_path[dist]
                right = right_path[dist + 1] if dist + 1 < len(right_path) else 0
                new_right[dist] = max(left, mid, right) + fruits[step][n - 1 - dist]

                left = bottom_path[dist - 1] if dist - 1 >= 0 else 0
                mid = bottom_path[dist]
                right = bottom_path[dist + 1] if dist + 1 < len(bottom_path) else 0
                new_bottom[dist] = max(left, mid, right) + fruits[n - 1 - dist][step]

            right_path = new_right
            bottom_path = new_bottom

            if window - n + 4 + step <= 1:
                window += 1
            elif window - n + 3 + step > 1:
                window -= 1

        return total + right_path[0] + bottom_path[0]

808. Soup Servings
from functools import lru_cache
import math

class Solution:
    def soupServings(self, n: int) -> float:
        if n > 5000:
            return 1.0
        units = math.ceil(n / 25)

        @lru_cache(None)
        def calc_prob(soupA, soupB):
            if soupA <= 0 and soupB <= 0:
                return 0.5
            if soupA <= 0:
                return 1.0
            if soupB <= 0:
                return 0.0
            return 0.25 * (
                calc_prob(soupA - 4, soupB) +
                calc_prob(soupA - 3, soupB - 1) +
                calc_prob(soupA - 2, soupB - 2) +
                calc_prob(soupA - 1, soupB - 3)
            )

        return calc_prob(units, units)

231. Power of Two
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n>0 and (1<<30)%n==0

869. Reordered Power of 2
class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        def count_digits(num):
            counts = [0] * 10
            if num == 0: 
                counts[0] = 1
                return tuple(counts)
            
            while num > 0:
                counts[num % 10] += 1
                num //= 10
            return tuple(counts)

        n_counts = count_digits(n)
        for i in range(30): 
            power_of_two = 1 << i  
            if count_digits(power_of_two) == n_counts:
                return True
        
        return False

2438. Range Product Queries of Powers
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        mod = 10**9 + 7
        power = []

        if n & 1:
            power.append(1)
        n >>= 1
        val = 1
        while n:
            val <<= 1  
            if n & 1:
                power.append(val)
            n >>= 1

        prefix = [1] * len(power)
        prefix[0] = power[0] % mod
        for i in range(1, len(power)):
            prefix[i] = (prefix[i-1] * power[i]) % mod

        res = []
        for i, j in queries:
            if i == 0:
                res.append(prefix[j] % mod)
            else:
                inv = pow(prefix[i-1], mod-2, mod)
                res.append((prefix[j] * inv) % mod)
        return res

2787. Ways to Express an Integer as Sum of Powers
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        from functools import lru_cache
        MOD = 10**9 + 7

        @lru_cache(None)
        def dp(remaining, current):
            if remaining == 0:
                return 1
            if remaining < 0 or current ** x > remaining:
                return 0

            power = current ** x
            # Try including current or skipping it
            include = dp(remaining - power, current + 1)
            skip = dp(remaining, current + 1)
            return (include + skip) % MOD

        return dp(n, 1)

326. Power of Three
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 3 == 0:
            n //= 3
        return n == 1

2264. Largest 3-Same-Digit Number in String
class Solution:
    def largestGoodInteger(self, num: str) -> str:
        for i in range(9,-1, -1): 
            check = (str(i) * 3)
            if check in num: 
                return check
        return ""
        
        
        


        
        
               
        
        
        


    
        

                
                
        
        
        

        

        
        
        
                    





        

        



        
        

        
        
         
        
        
        
        
        
        
        
        
        


        
        

          
        
       
        
        
        
        
        
        
        


        


