3151. Special Array I
class Solution:
    def isArraySpecial(self, nums: List[int]) -> bool:
        for i in range(len(nums)-1):
            if nums[i]%2 == nums[i+1]%2:
                return False
        return True

1752. Check if Array Is Sorted and Rotated
class Solution:
    def check(self, nums: List[int]) -> bool:
        c=0
        n=len(nums)
        for i in range(n):
            if nums[i]>nums[(i+1)%n]:
                c+=1
        if c>1:
            return False
        return True

3105. Longest Strictly Increasing or Strictly Decreasing Subarray
class Solution:
    def longestMonotonicSubarray(self, nums: List[int]) -> int:
        c=1
        r=1
        inc=0
        for i in range(1,len(nums)):
            if nums[i-1]<nums[i]:
                if inc>0:
                    c+=1
                else:
                    c=2
                    inc=1
            elif nums[i-1]>nums[i]:
                if inc<0:
                    c+=1
                else:
                    c=2
                    inc=-1
            else:
                c=1
                inc=0
            r=max(r,c)
        return r
1800. Maximum Ascending Subarray Sum
class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        c=nums[0]
        r=c
        for i in range(1,len(nums)):
            if not (nums[i-1]<nums[i]):
                c=0
            c+=nums[i]
            r=max(r,c)
        return r
1790. Check if One String Swap Can Make Strings Equal
class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        ind=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                ind.append(i)
            if len(ind)>2:
                return False
        if len(ind)==2:
            i,j=ind
            return s1[i]==s2[j] and s1[j]==s2[i]
        return len(ind)==0

1726. Tuple with Same Product
class Solution:
    def tupleSameProduct(self, nums: List[int]) -> int:
        d={}
        a=0
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                p=nums[i]*nums[j]

                if p in d:
                    a+=(d[p]*8)
                    d[p]+=1
                else:
                    d[p]=1
        return a

3160. Find the Number of Distinct Colors Among the Balls
class Solution:
    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:
        n=len(queries)
        ans=[0]*n
        mp={}
        color=defaultdict(int)
        i=0
        for x, c in queries:
            if x in mp:
                c0=mp[x]
                color[c0]-=1
                if color[c0]==0:
                    color.pop(c0)
            mp[x]=c
            color[c]+=1
            ans[i]=len(color)
            i+=1
        return ans
        
2349. Design a Number Container System
class NumberContainers:

    def __init__(self):
        self.mp={}
        self.idx=defaultdict(list)

    def change(self, index: int, number: int) -> None:
        self.mp[index]=number
        heappush(self.idx[number], index)
        

    def find(self, number: int) -> int:
        if number not in self.idx:
            return -1
        while self.idx[number]:
            i=self.idx[number][0]
            if self.mp[i]==number: return i
            heappop(self.idx[number])
        return -1
--- 9-2-2025
3174. Clear Digits
class Solution:
    def clearDigits(self, s: str) -> str:
        k=0
        s=list(s)
        for i,c in enumerate(s):
            if c.isdigit() and k>0:
                k-=1
            else:
                s[k]=c
                k+=1
        s=s[:k]
        return "".join(s) 
1910. Remove All Occurrences of a Substring
class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        while part in s:
            s=s.replace(part,"",1)
        return s
2342. Max Sum of a Pair With Equal Sum of Digits
class Solution:
    def maximumSum(self, nums: List[int]) -> int:
        def sum_digit(i):
            sum=0
            while(i):
                sum+=i%10
                i//=10
            return sum
        pairs=[]
        for n in nums:
            sum=sum_digit(n)
            pairs.append((sum,n))
        pairs.sort()
        max_sum=-1
        for i in range(1,len(nums)):
            if pairs[i][0]==pairs[i-1][0]:
                present=pairs[i][1]+pairs[i-1][1]
                max_sum=max(max_sum,present)
        return max_sum
3066. Minimum Operations to Exceed Threshold Value II

class Solution(object):
    def minOperations(self, nums, k):
        heapq.heapify(nums)
        res=0

        for i in range(0, len(nums)):
            x=heapq.heappop(nums)
            if x<k:
                res+=1
                y=heapq.heappop(nums)
                val= x*2+y if (x<y) else y*2+x
                heapq.heappush(nums, val)
            else:
                break

        return res

1352. Product of the Last K Numbers
class ProductOfNumbers:

    def __init__(self):
        self.product=[1]
        self.n=1

    def add(self, num: int) -> None:
        if num==0:
            self.product=[1]
            self.n=1
        else:
            self.product.append(self.product[-1]*num)
            self.n+=1

    def getProduct(self, k: int) -> int:
        if self.n<=k:
            return 0
        else:
            return self.product[-1]//self.product[-k-1]
        


# Your ProductOfNumbers object will be instantiated and called as such:
# obj = ProductOfNumbers()
# obj.add(num)
# param_2 = obj.getProduct(k)

2698. Find the Punishment Number of an Integer
class Solution:
    def punishmentNumber(self, n: int) -> int:
        arr = [1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,
               657,675,703,756,792,909,918,945,964,990,991,999,1000]
        
        total = 0
        for num in arr:
            if num <= n:
                total += num * num
            else:
                break
        return total
1718. Construct the Lexicographically Largest Valid Sequence
class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        len_seq = 2 * n - 1
        seq = [0] * len_seq 
        used = set() 
        def backtrack(i):
            if i == len_seq: return True 
            if seq[i]: return backtrack(i + 1) 

            for num in range(n, 0, -1): 
                if num in used: continue 

                nxt = i + num if num > 1 else i 

                if nxt >= len_seq or seq[nxt] != 0: continue 
                
                seq[i] = seq[nxt] = num 
                used.add(num)

                if backtrack(i + 1): 
                    return True

                seq[i] = seq[nxt] = 0 
                used.remove(num)

            return False 

        backtrack(0)
        return seq 
1079. Letter Tile Possibilities
class Solution:
    def numTilePossibilities(self, tiles: str) -> int:
        return len(set(p for i in range(1, len(tiles)+1) for p in permutations(tiles, i)))
2375. Construct Smallest Number From DI String
class Solution:
    def smallestNumber(self, pattern: str) -> str:
        stack = ['', '1']  
        prev = pattern[0] 
        for num, i in enumerate(pattern + 'S', 2): 
            if i != prev: 
                if prev == 'D': 
                    stack[-2] = stack[-2][:-1] + stack[-1][::-1]
                else:  
                    stack[-2] = stack[-2][:-1] + stack[-1]
                stack[-1] = stack[-2][-1] + str(num)
                prev = i
            else:
                stack[-1] += str(num)
        
        return stack[0] 
1415. The k-th Lexicographical String of All Happy Strings of Length n
class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        count = 0 
        def backtrack(i, chars):
            nonlocal count
            if i == n: 
                count += 1 
                return "".join(chars) if count == k else ""    
            for c in "abc": 
                if chars and chars[-1] == c: continue 
                res = backtrack(i + 1, chars + [c]) 
                if res:
                    return res 
            return ""     
        return backtrack(0, [])
1980. Find Unique Binary String
class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        r=[]
        for i in range(0,len(nums)):
            if nums[i][i]=='0':
                r.append('1')
            else:
                r.append('0')
        return "".join(r)
1261. Find Elements in a Contaminated Binary Tree
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class FindElements:

    def __init__(self, root: Optional[TreeNode]):
        self.hasX=set()
        def bfs(root):
            q=deque()
            root.val=0
            q.append(root)

            while q:
                node=q.popleft()
                x=node.val
                self.hasX.add(x)

                if node.left:
                    node.left.val=2*x+1
                    q.append(node.left)
                if node.right:
                    node.right.val=2*x+2
                    q.append(node.right)
        bfs(root)
        

    def find(self, target: int) -> bool:
        return target in self.hasX
        


# Your FindElements object will be instantiated and called as such:
# obj = FindElements(root)
# param_1 = obj.find(target)

1028. Recover a Tree From Preorder Traversal
class Solution:
    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:
        nodes = [(len(node[1]), int(node[2])) for node in re.findall("((-*)(\d+))", traversal)][::-1]
        def makeTree(depth): 
            if not nodes or depth != nodes[-1][0]: return None 
            node = TreeNode(nodes.pop()[1])
            node.left = makeTree(depth + 1)  
            node.right = makeTree(depth + 1)

            return node

        return makeTree(0) 
889. Construct Binary Tree from Preorder and Postorder Traversal
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not preorder and not postorder:
            return None
        root=TreeNode(preorder[0])
        if len(preorder)==1:
            return root
        left_root_val=preorder[1]
        left_subtree_size=postorder.index(left_root_val)+1
        root.left=self.constructFromPrePost(preorder[1:left_subtree_size+1],postorder[:left_subtree_size])
        root.right=self.constructFromPrePost(preorder[left_subtree_size+1:],postorder[left_subtree_size:-1])
        return root
2467. Most Profitable Path in a Tree
class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        n=len(edges)+1
        adj=[[] for _ in range(n)]
        parent=[-1]*n
        Bob=[float('inf')]*n 

        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        def dfs(i, p):
            parent[i] = p
            for j in adj[i]:
                if j == p: continue
                dfs(j, i)

        dfs(0, -1)  
        x=bob
        move=0
        while x!=-1:
            Bob[x]=move
            move+=1
            x=parent[x]
        def dfs_sum(i, dist, prev):
            alice=0
            if dist < Bob[i]:
                alice=amount[i]  
            elif dist==Bob[i]:
                alice=amount[i]//2  

            isLeaf=True
            maxLeafSum=-float('inf')

            for j in adj[i]:
                if j == prev: continue
                isLeaf=False
                maxLeafSum = max(maxLeafSum, dfs_sum(j, dist+1, i))

            return alice if isLeaf else alice + maxLeafSum

        return dfs_sum(0, 0, -1)
1524. Number of Sub-arrays With Odd Sum
class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        sum_is_odd=0
        cnt=[1, 0]
        ans=0
        for x in arr:
            sum_is_odd^=(x&1)
            ans+=cnt[1-sum_is_odd]
            cnt[sum_is_odd]+=1
        return ans%(10**9+7)  
        
1524. Number of Sub-arrays With Odd Sum
class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        sum_is_odd=0
        cnt=[1, 0]
        ans=0
        for x in arr:
            sum_is_odd^=(x&1)
            ans+=cnt[1-sum_is_odd]
            cnt[sum_is_odd]+=1
        return ans%(10**9+7)
1749. Maximum Absolute Sum of Any Subarray
class Solution:
    def maxAbsoluteSum(self, nums: List[int]) -> int:
        return max(0, max(K:=list(accumulate(nums))))-min(0, min(K))
873. Length of Longest Fibonacci Subsequence
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        fib_lens = {}
        set_arr = set(arr) 

        for b, c in combinations(arr, 2):
            a = c - b 
            if a < b and a in set_arr: 
                fib_lens[(b, c)] = fib_lens.get((a, b), 2) + 1
                
        return max(fib_lens.values(), default = 0) 
1092. Shortest Common Supersequence 
class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        i, j = m, n
        scs = []
    
        while i > 0 or j > 0:
            if i > 0 and j > 0 and str1[i - 1] == str2[j - 1]:  
                scs.append(str1[i - 1])
                i -= 1
                j -= 1
            elif i > 0 and (j == 0 or dp[i - 1][j] >= dp[i][j - 1]): 
                scs.append(str1[i - 1])
                i -= 1
            else: 
                scs.append(str2[j - 1])
                j -= 1
    
        scs.reverse()
        return "".join(scs)     
2460. Apply Operations to an Array
class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        n, i=len(nums), 0
        while i<n-1:
            if nums[i]==nums[i+1]:
                nums[i], nums[i+1]=nums[i]<<1, 0
                i+=1
            i+=1
        j=0
        for x  in nums:
            if x>0:
                nums[j]=x
                j+=1
        nums[j:]=[0]*(n-j)
        return nums
2570. Merge Two 2D Arrays by Summing Values
class Solution:
    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        d={}
        for i in nums1:
            if i[0] not in d:
                d[i[0]]=i[1]
            else:
                d[i[0]]+=i[1]
        for i in nums2:
            if i[0] not in d:
                d[i[0]]=i[1]
            else:
                d[i[0]]+=i[1]
        ans=[]
        # print(d)
        for i in sorted(d.keys()):
            l=[]
            l.append(i)
            l.append(d[i])
            ans.append(l)

        return ans
2161. Partition Array According to Given Pivot
class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        x=[]
        y=[]
        z=[]
        for i in nums:
            if i==pivot:
                z.append(i) 
            elif i<pivot:
                x.append(i)
            else :
                y.append(i)
        return x+z+y
1780. Check if Number is a Sum of Powers of Three
class Solution:
    def checkPowersOfThree(self, n: int) -> bool:
        while n>0:
            q, r=divmod(n, 3)
            if r==2: return False
            n=q
        return True
2579. Count Total Number of Colored Cells
class Solution:
    def coloredCells(self, n: int) -> int:
        return 2*n*(n-1)+1
2965. Find Missing and Repeated Values
class Solution:
    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:
        n = len(grid)
        missing = (n * n) * (1 + n * n) // 2 
        seen = set() 
        duplicate = -1
        for row in grid:
            for num in row:
                if num not in seen:
                    seen.add(num)
                    missing -= num 
                else:
                    duplicate = num
                    
        return [duplicate, missing]
2523. Closest Prime Numbers in Range
class Solution:
        
    def closestPrimes(self, left: int, right: int) -> List[int]:
        def primeFind(val: int)->bool:
            if val==1: return False
            elif val==2: return True

            for i in range(2, int(val**0.5)+1):
                if val%i==0:
                    return False
            return True

        res=[-1,-1]
        prime=[]

        for p in range(left, right+1):
            if primeFind(p):
                if len(prime)>=1 and p<=prime[len(prime)-1]+2:
                    return [prime[len(prime)-1], p]
                prime.append(p)
        

        if len(prime)<2:
            return res

        minVal=sys.maxsize
        for i in range(1, len(prime)):
            if minVal>prime[i]-prime[i-1]:
                minVal=prime[i]-prime[i-1]
                res=[prime[i-1], prime[i]] 

        return res
2379. Minimum Recolors to Get K Consecutive Black Blocks
class Solution:
    def minimumRecolors(self, blocks: str, k: int) -> int:
        n=len(blocks)
        recolor=W=blocks[:k].count('W')
        for l in range(n-k):
            W+=(blocks[l+k]=='W')-(blocks[l]=='W')
            recolor=min(recolor, W)
        return recolor
3208. Alternating Groups II
class Solution:
    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:
        n=len(colors)
        s=n+k-1
        ans, alt, prev=0, 1, colors[0]
        for i in range(1, s):
            i0=i%n
            alt=1 if prev==colors[i0] else alt+1
            ans+=(alt>=k)
            prev=colors[i0]
        return ans
3306. Count of Substrings Containing Every Vowel and K Consonants II
class Solution:
    def countOfSubstrings(self, word: str, k: int) -> int:
        n = len(word)
        vowels = set('aeiou')
        vowel_count, cons_count = defaultdict(int), 0 
        left = count = substrs = 0 

        def minus_char(char):
            if char in vowels:
                vowel_count[char] -= 1
                if vowel_count[char] == 0:
                    del vowel_count[char] 
            else:
                nonlocal cons_count
                cons_count -= 1

        for char in word:
            if char in vowels:
                vowel_count[char] += 1
            else:
                cons_count += 1
                count = 0

            while cons_count > k: 
                minus_char(word[left])
                left += 1
            while cons_count == k and len(vowel_count) == 5:
                count += 1 
                minus_char(word[left])
                left += 1 
            substrs += count

        return substrs
1358. Number of Substrings Containing All Three Characters
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        n, cnt, letter, l=len(s), 0, 0, 0
        freq=[0]*3
        for r, c in enumerate(s):
            freq[ord(c)-97]+=1
            if freq[ord(c)-97]==1: letter+=1
            while letter==3:
                freq[ord(s[l])-97]-=1
                if freq[ord(s[l])-97]==0: letter-=1
                l+=1
            cnt+=l
        return cnt
2529. Maximum Count of Positive Integer and Negative Integer
class Solution:
    def maximumCount(self, nums: List[int]) -> int:
        return max(len(nums)-bisect_right(nums,0), bisect_left(nums, 0))
3356. Zero Array Transformation II
class Solution:
    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:
        n, m=len(nums), len(queries)
        freq=[0]*(n+1)
        op, k=0, 0
        for i in range(n):
            while op<nums[i]-freq[i]:
                if k>=m: 
                    return -1
                l, r, v=queries[k]
                if r<i:
                    k+=1 
                    continue
                freq[max(l, i)]+=v
                freq[r+1]-=v
                k+=1
            op+=freq[i]
        return k 
2226. Maximum Candies Allocated to K Children
class Solution:
    def maximumCandies(self, candies: List[int], k: int) -> int:
        def get_c(c, k):
            for x in candies:
                k-=x//c
                if k<=0: 
                    return True
            return False
        Sum=sum(candies)
        if Sum<k: 
            return 0
        l, r=1, Sum//k
        while l<r:
            m=(l+r+1)//2
            if get_c(m, k): 
                l=m
            else: 
                r=m-1
        return l
2560. House Robber IV
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        n=len(nums)
        x0=min(nums)
        xM=max(nums)
        def f(cap):
            steal, i=0, 0
            while i<n and steal<=k:
                if nums[i]<=cap:
                    steal+=1
                    i+=1
                i+=1
            return steal>=k

        l, r=x0, xM
        while l<r:
            m=(l+r)>>1
            if f(m):
                r=m
            else:
                l=m+1
        return l
2594. Minimum Time to Repair Cars
class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        freq=Counter(ranks)
        minR=min(ranks)
    #    maxR=max(ranks) # no need
        def canRepair(t):
            cnt=0
            for x, f in freq.items():
                cnt+=f*(sqrt(t/x)//1)
                if cnt>=cars: return True
            return cnt>=cars
        
        l, r=1, minR*cars*cars
        while l<r:
            m=(l+r)>>1
            if canRepair(m):
                r=m
            else:
                l=m+1
        return l
Divide Array Into Equal Pairs
class Solution:
    def divideArray(self, nums: List[int]) -> bool:
        a=0
        for i in nums:
            a^=(1<<i)
        return a==0
2401. Longest Nice Subarray
class Solution:
    def longestNiceSubarray(self, nums: List[int]) -> int:
        n, ans, B, l=len(nums), 0, 0, 0
        for r, x in enumerate(nums):
            while l<r and (B& x)!=0:
                B^=nums[l]
                l+=1
            B|=x
            ans=max(ans, r-l+1)
        return ans
3191. Minimum Operations to Make Binary Array Elements Equal to One I
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n, i0, op = len(nums), -1, 0
        nums.append(0) 
        while True:
            i0 = nums.index(0, i0+1)  
            if i0 >= n-2:  
                break  
            nums[i0+1] ^=1 
            nums[i0+2] ^=1 
            op+=1  
        return op if i0>=n else -1  
3108. Minimum Cost Walk in Weighted Graph
from typing import List

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.weights = [131071] * n  
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y, w):
        repX = self.find(x)
        repY = self.find(y)
        if repX != repY:
            if self.rank[repX] >= self.rank[repY]:
                self.parent[repY] = repX
                self.rank[repX] += self.rank[repY]
            else:
                self.parent[repX] = repY
                self.rank[repY] += self.rank[repX]
        self.weights[repX] = self.weights[repY] = self.weights[repX] & self.weights[repY] & w

    def path_weight(self, node):
        return self.weights[self.find(node)]

class Solution:
    def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:
        dsu = UnionFind(n)
        for u, v, w in edges:
            dsu.union(u, v, w)

        res = []
        for s, t in query:
            if dsu.find(s) == dsu.find(t):
                res.append(dsu.path_weight(s))
            else:
                res.append(-1)

        return res
2115. Find All Possible Recipes from Given Supplies
class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]: 
        supplies = set(supplies)
        recipes = dict(zip(recipes, ingredients))
        made = []
        while True:
            new_recipe_made = False
            for rcp, igs in [*recipes.items()]:
                if not all(i in supplies for i in igs):
                    continue
                made.append(rcp)
                supplies.add(rcp)
                del recipes[rcp]
                new_recipe_made = True

            if not new_recipe_made: 
                break
        return made
2685. Count the Number of Complete Components
class UnionFind:
    def __init__(self, N):
        self.root = list(range(N))
        self.Size = [1]*N

    def Find(self, x):
        if self.root[x] != x:
            self.root[x] = self.Find(self.root[x])  # path compression
        return self.root[x]

    def Union(self, x, y):
        x = self.Find(x)
        y = self.Find(y)
        if x==y: return False

        if self.Size[x] > self.Size[y]:
            self.Size[x] += self.Size[y]
            self.root[y]=x
        else:
            self.Size[y] += self.Size[x]
            self.root[x]=y
        return True
class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        m=len(edges)
        if m==n*(n-1)//2: 
            return 1

        G=UnionFind(n)
        eN=[0]*n
        for v, w in edges:
            a=eN[G.Find(v)]
            b=eN[G.Find(w)]
            if G.Union(v, w):
                eN[G.Find(v)]=a+b+1
            else:
                eN[G.Find(v)]=a+1
        ans=0
        for i, v in enumerate(G.Size):
            if G.Find(i)==i and eN[i]==v*(v-1)//2:
                ans+=1
        return ans
1976. Number of Ways to Arrive at Destination
from typing import List
from collections import defaultdict
import heapq

class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        MOD = 10**9 + 7

        # Build the graph
        graph = defaultdict(list)
        for u, v, time in roads:
            graph[u].append((v, time))
            graph[v].append((u, time))

        # Dijkstra's initialization
        min_heap = [(0, 0)]  # (time, node)
        shortest_time = [float('inf')] * n
        pathCount = [0] * n
        shortest_time[0] = 0
        pathCount[0] = 1

        while min_heap:
            curr_time, u = heapq.heappop(min_heap)

            # Skip if we already found a better time
            if curr_time > shortest_time[u]:
                continue

            for v, t in graph[u]:
                new_time = curr_time + t

                if new_time < shortest_time[v]:
                    shortest_time[v] = new_time
                    pathCount[v] = pathCount[u]
                    heapq.heappush(min_heap, (new_time, v))

                elif new_time == shortest_time[v]:
                    pathCount[v] = (pathCount[v] + pathCount[u]) % MOD

        return pathCount[n - 1] % MOD
3169. Count Days Without Meetings
class Solution:
    def countDays(self, days: int, meetings: list[list[int]]) -> int:
        t = 0
        for i, j in sorted(meetings, key=lambda x: x[0]):
            if j <= t:
                continue
            elif i > t:
                days -= j - i + 1
            else:
                days -= j - t
            t = j
            
        return days
3394. Check if Grid can be Cut into Sectionsclass Solution:
    def checkValidCuts(self, n: int, a: List[List[int]]) -> bool:
        sx,sy,ex,ey = zip(*a)
        return any(sum(starmap(le,zip(accumulate([0,*b],max),a)))>2
            for a,b in starmap(zip,map(sorted,map(zip,(sx,sy),(ex,ey))))
        )
2033. Minimum Operations to Make a Uni-Value Grid
class Solution:
    def minOperations(self, grid: List[List[int]], x: int) -> int:
        arr = [num for row in grid for num in row]  
        arr.sort()
        median = arr[len(arr) // 2]  
        for num in arr:
            if (num - median) % x != 0:
                return -1  
        return sum(abs(num - median) // x for num in arr)
2780. Minimum Index of a Valid Split
class Solution:
    def minimumIndex(self, nums: List[int]) -> int:
        c= 0
        d, c1 = max(Counter(nums).items(), key=lambda x: x[1])
        for i, x in enumerate(nums):
            c+= x == d
            c1-= x == d
            if c> (i + 1) // 2 and c1 > (len(nums) - (i + 1)) // 2:
                return i
        return -1
2503. Maximum Number of Points From Grid Queries
class Solution:
    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:
        m, n = len(grid), len(grid[0])

        visited = set([(0, 0)])
        visiting = [(0, 0)]
        dropped = []

        scores = {}
        curr_score = 0

        for q in sorted(set(queries)):
            while visiting:
                next_visit = []
                for x, y in visiting:
                    if grid[x][y] < q:
                        curr_score += 1
                        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
                            if 0 <= x + dx and m > x + dx and \
                                0 <= y + dy and n > y + dy and \
                                (x + dx, y + dy) not in visited:
                                next_visit.append((x + dx, y + dy))
                                visited.add((x + dx, y + dy))
                    else:
                        dropped.append((x, y))
                visiting = next_visit
            scores[q] = curr_score
            visiting = dropped
            dropped = []

        return [scores.get(q, 0) for q in queries ]
2818. Apply Operations to Maximize Score
class Solution:
    def countDistinctPrimeFactors(self, n: int) -> int:
        count = 0
        if n % 2 == 0:
            count += 1
            while n % 2 == 0:
                n //= 2
        
        i = 3
        while i * i <= n:
            if n % i == 0:
                count += 1
                while n % i == 0:
                    n //= i
            i += 2 
        if n > 1:
            count += 1
        return count

    def modPow(self, base: int, exp: int, mod: int) -> int:
        result = 1
        b = base % mod
        while exp > 0:
            if exp & 1:
                result = (result * b) % mod
            b = (b * b) % mod
            exp >>= 1
        return result

    def maximumScore(self, nums: List[int], k: int) -> int:
        MOD = 1_000_000_007
        n = len(nums)
        if n == 0:
            return 1

        maxValues = [(-nums[i], i) for i in range(n)]  # Min heap with negative values for max heap behavior
        heapq.heapify(maxValues)
        
        rightLarge = [n] * n
        leftLarge = [-1] * n
        primeScores = [self.countDistinctPrimeFactors(nums[i]) for i in range(n)]
        
        stack = []
        for i in range(n):
            while stack and primeScores[i] > primeScores[stack[-1]]:
                rightLarge[stack.pop()] = i
            stack.append(i)
        
        stack.clear()
        for i in range(n - 1, -1, -1):
            while stack and primeScores[i] >= primeScores[stack[-1]]:
                leftLarge[stack.pop()] = i
            stack.append(i)

        score = 1

        while maxValues and k > 0:
            val, idx = heapq.heappop(maxValues)
            val = -val  # Convert back to positive

            t = (rightLarge[idx] - idx) * (idx - leftLarge[idx])
            steps = min(t, k)

            multiply = self.modPow(val, steps, MOD)
            score = (score * multiply) % MOD

            k -= steps

        return score % MOD
763. Partition Labels
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        letters = set()
        first = {}
        last = {}
        ranges = []
        for i in range(len(s)):
            letter = s[i]
            letters.add(letter)
            if letter not in first:
                first[letter] = i
                last[letter] = i
            else:
                last[letter] = i
        for letter in letters:
            ranges.append([first[letter], last[letter]])
        ranges.sort()
        merged = [ranges[0]]
        for r in ranges[1:]:
            start, end = merged[-1]
            new_start, new_end = r
            if new_start < end:
                merged[-1] = [start, max(end, new_end)]
            else:
                merged.append(r)
        return [end - start + 1 for start, end in merged]

2551. Put Marbles in Bags
class Solution:
    def putMarbles(self, weights: List[int], k: int) -> int:
        if k == 1 or  k == len(weights):
            return 0
        pair_sums = []
        for i in range(len(weights) - 1):
            pair_sums.append(weights[i] + weights[i+1])
        pair_sums.sort()
        min_score = sum(pair_sums[:k-1])
        max_score = sum(pair_sums[-(k-1):])   
        return max_score - min_score
2140. Solving Questions With Brainpower
class Solution:
    def mostPoints(self, questions: List[List[int]]) -> int:
        n = len(questions)
        dp = [q[0] for q in questions]

        for i in range(n-2,-1,-1):
            out_range = i + questions[i][1] + 1
            if out_range < n:
                dp[i] += dp[out_range]
            dp[i] = max(dp[i],dp[i+1])
        return dp[0]
2874. Maximum Value of an Ordered Triplet II
class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        n=len(nums)
        L=[0]*n
        R=[0]*n
        for i in range(n-1):
            L[i+1]=max(L[i], nums[i])
            R[n-2-i]=max(R[n-i-1], nums[n-i-1])
        return max(0,max((L[i]-nums[i])*R[i] for i in range(1, n-1)))
1123. Lowest Common Ancestor of Deepest Leaves
1123. Lowest Common Ancestor of Deepest Leaves# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def dfs(node):
            if not node: return (0, None) # (depth, lca)
            l, llca = dfs(node.left)
            r, rlca = dfs(node.right)
            if l == r: return (l + 1, node)
            return (l + 1, llca) if l > r else (r + 1, rlca)
        return dfs(root)[1]
1863. Sum of All Subset XOR Totals
class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0
        for i in range(1 << n):
            x = 0
            for j in range(n):
                if (1 << j) & i:
                    x ^= nums[j]
            res += x
        return res
368. Largest Divisible Subset
class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        dp = [[num] for num in nums]

        for i in range(len(nums)):
            for j in range(i):
                if nums[i] % nums[j] == 0 and len(dp[j]) + 1 > len(dp[i]):
                    dp[i] = dp[j] + [nums[i]]

        return max(dp, key=len)

416. Partition Equal Subset Sum
class Solution:
    def canPartition(self, nums: list[int]) -> bool:
        target, isOdd = divmod(sum(nums), 2)
        if isOdd: return False
        bitmap = 1
        for num in nums: bitmap|= bitmap << num
        return bool(bitmap & (1 << target)) 
3396. Minimum Number of Operations to Make Elements in Array Distinct
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        a=0
        while len(nums)>len(set(nums)):
            nums=nums[3:]
            a+=1
        return a
3375. Minimum Operations to Make Array Values Equal to K
class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        hasX=0
        xMin=101
        for x in nums:
            hasX|=1<<x
            xMin=min(x, xMin)
        
        if xMin<k: return -1
        B=hasX.bit_count()
        return B-1 if xMin==k else B

2999. Count the Number of Powerful Integers
class Solution:
    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:
        s_start = str(start - 1)
        s_finish = str(finish)
        return self.count_powerful(s_finish, s, limit) - self.count_powerful(s_start, s, limit)
    
    def count_powerful(self, num: str, suffix: str, limit: int) -> int:
        if len(num) < len(suffix):
            return 0
        if len(num) == len(suffix):
            return 1 if num >= suffix else 0
        
        result = 0
        prefix_len = len(num) - len(suffix)
        
        for i in range(prefix_len):
            digit = int(num[i])

            if digit > limit:
                result += (limit + 1) ** (prefix_len - i)
                return result
            result += digit * (limit + 1) ** (prefix_len - i - 1)
        
        if num[-len(suffix):] >= suffix:
            result += 1        
        return result
2843. Count Symmetric Integers
class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        c = 0 
        for num in range(low, high + 1):
            s = str(num) 
            n = len(s)

            if n % 2 != 0:
                continue  
            half = n // 2
            left = sum(int(s[i]) for i in range(half))  
            right = sum(int(s[i]) for i in range(half, n))  

            if left == right:
                c += 1 

        return c
3272. Find the Count of Good Integers
class Solution:
    def countGoodIntegers(self, n: int, k: int) -> int:
        if n == 1:
            total = 0
            for i in range(1, 10):
                if i % k == 0:
                    total += 1
            return total
        fact = [1]
        for i in range(1, n + 1):
            fact.append(fact[-1] * i)
        seen = set()
        ans = 0
        for left in range(10 ** ((n - 1) // 2), 10 ** ((n + 1) //2)):
            l = str(left)
            r = l[::-1]
            if n % 2 == 1:
                r = r[1:]
            t = l + r
           
            if int(t) % k != 0:
                continue

            s = "".join(sorted(list(t)))
            if s in seen:
                continue
            seen.add(s)

            count = Counter(t)

            total = fact[n]
            for key in count.keys():
                total //= fact[count[key]]

            ans += total
            if count["0"] >= 1:
                total_non_zero = fact[n - 1]
                count["0"] -= 1
                for key in count.keys():
                    total_non_zero //= fact[count[key]]
                ans -= total_non_zero   

        return ans
1922. Count Good Numbers
class Solution:
    m=10**9+7
    def countGoodNumbers(self, n: int) -> int:
        even=(n+1)//2
        odd=n//2
        e=self.fun(5,even)
        o=self.fun(4,odd)
        return (e*o)%self.m

    def fun(self,a,b):
        r=1
        a%=self.m

        while b>0:
            if b%2==1:
                r=(r*a)%self.m
            a=(a*a)%self.m
            b//=2
        return r
1534. Count Good Triplets
class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        n = len(arr)
        count = 0
        for i in range(n - 2):
            ai = arr[i]
            for j in range(i + 1, n - 1):
                aj = arr[j]
                if abs(ai - aj) > a:
                    continue
                for k in range(j + 1, n):
                    ak = arr[k]
                    diff_jk = abs(aj - ak)
                    if diff_jk > b:
                        continue
                    if abs(ai - ak) <= c:
                        count += 1
        return count
2537. Count the Number of Good Subarrays

class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        n=len(nums)
        freq=defaultdict(int)
        ans, cnt, l=0, 0, 0
        for r,x in enumerate(nums):
            cnt+=freq[x]
            freq[x]+=1
            while cnt>=k:
                ans+=n-r
                freq[nums[l]]-=1
                cnt-=freq[nums[l]]
                l+=1
        return ans

2176. Count Equal and Divisible Pairs in an Array

class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        a=[[] for i in range(101)]
        c=0
        for j, x in enumerate(nums):
            for i in a[x]:
                c+=(i*j%k==0)
            a[x].append(j)
        return c
38. Count and Say
class Solution:
    def countAndSay(self, n: int) -> str:
        s="1"
        while n-1>0:
            curr=s[0]
            c=1
            ans=""
            for i in range(1,len(s)):
                if curr==s[i]:
                    c+=1
                else:
                    ans+=str(c)
                    ans+=curr
                    curr=s[i]
                    c=1
            ans+=str(c)
            ans+=curr
            s=ans
            n-=1
        print(s)
        return s

2563. Count the Number of Fair Pairs
from bisect import bisect_left, bisect_right

class Solution:
    def countFairPairs(self, v, lower, upper):
        v.sort()
        ans = 0
        for i in range(len(v) - 1):
            low = bisect_left(v, lower - v[i], i + 1)
            up = bisect_right(v, upper - v[i], i + 1)
            ans += up - low
        return ans
781. Rabbits in Forest

class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        answers.sort()
        a=0
        c=0
        for i in range(len(answers)):
            if answers[i]==0:
                a+=1
            elif i==0 or answers[i]!=answers[i-1] or c==0:
                a+=answers[i]+1
                c=answers[i]
            else:
                c-=1
        return a

2145. Count the Hidden Sequences
class Solution:
    def numberOfArrays(self, diff: List[int], lower: int, upper: int) -> int:
        return (K:=list(accumulate(diff, initial=0))) and max(0, upper-lower+1-max(K)+min(K))

2338. Count the Number of Ideal Arrays
from collections import Counter
from math import comb

class Solution:
    def idealArrays(self, length: int, max_value: int) -> int:
        MOD = 1_000_000_007
        total_ways = max_value
        frequency_map = {num: 1 for num in range(1, max_value + 1)}
        
        for array_size in range(1, length): 
            new_frequency = Counter()
            for base_value in frequency_map: 
                for multiplier in range(2, max_value // base_value + 1): 
                    combinations = comb(length - 1, array_size)
                    total_ways += combinations * frequency_map[base_value]
                    new_frequency[multiplier * base_value] += frequency_map[base_value]
            frequency_map = new_frequency
            total_ways %= MOD
        
        return total_ways

1399. Count Largest Group
class Solution:
    def countLargestGroup(self, n: int) -> int:
        freq=[0]*37
        maxF, sz=1, 1
        freq[1]=1
        for x in range(2, n+1):
            digit_sum, y=0, x
            while y>0:
                q, r=divmod(y, 10)
                digit_sum+=r
                y=q
            freq[digit_sum]+=1
            f=freq[digit_sum]
            if f==maxF: 
                sz+=1
            elif f>maxF:
                maxF=f
                sz=1
        return sz
2799. Count Complete Subarrays in an Array

from collections import defaultdict

class Solution:
    def countCompleteSubarrays(self, nums: List[int]) -> int:
        total_distinct = len(set(nums))
        count = defaultdict(int)
        left = res = 0

        for right in range(len(nums)):
            count[nums[right]] += 1
            while len(count) == total_distinct:
                res += len(nums) - right
                count[nums[left]] -= 1
                if count[nums[left]] == 0:
                    del count[nums[left]]
                left += 1
        return res
2444. Count Subarrays With Fixed Bounds

class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        total = 0
        last_invalid = last_min = last_max = -1

        for i, num in enumerate(nums):
            if num < minK or num > maxK:
                last_invalid = i
            if num == minK:
                last_min = i
            if num == maxK:
                last_max = i

            valid_start = min(last_min, last_max)
            total += max(0, valid_start - last_invalid)

        return total

3392. Count Subarrays of Length Three With a Condition
class Solution:
    def countSubarrays(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums) - 2):
            if (nums[i] + nums[i+2]) * 2 == nums[i+1]:
                count += 1
        return count

2302. Count Subarrays With Score Less Than K

class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        start = 0
        sum_ = 0
        count = 0
        
        for end in range(len(nums)):
            sum_ += nums[end]
            
            while sum_ * (end - start + 1) >= k:
                sum_ -= nums[start]
                start += 1
            
            count += (end - start + 1)
        
        return count
2962. Count Subarrays Where Max Element Appears at Least K Times

class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        max_element = max(nums)
        res = 0
        left = maxi_count = 0
        
        for right in range(len(nums)):
            if nums[right] == max_element:
                maxi_count += 1
            while maxi_count == k:
                res += len(nums) - right
                if nums[left] == max_element:
                    maxi_count -= 1
                left += 1
        
        return res

1295. Find Numbers with Even Number of Digits

class Solution:
    def findNumbers(self, nums: List[int]) -> int:
        c=0
        for i in nums:
            s=str(i)
            l=len(s)
            if l%2==0:
                c+=1
        return c
2071. Maximum Number of Tasks You Can Assign

class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int],pills: int, strength: int) -> int:

        def cannot_complete(numTasks: int, p = pills)-> bool:
            cnt = 0 
            jobs = deque()
            
            for i in range(numTasks - 1, -1, -1): 
                while cnt < numTasks:
                    if tasks[cnt] > workers[i] + strength: break
                    jobs.append(tasks[cnt])
                    cnt += 1
                
                if not jobs:
                    return True
                
                if workers[i] >= jobs[0]:
                    jobs.popleft()
                elif p > 0:
                    jobs.pop()
                    p -= 1
                else:
                    return True

            return False


        tasks.sort()
        workers.sort(reverse = True)
        n = min(len(tasks), len(workers)) + 1

        return bisect_left(range(n), True, key = cannot_complete) - 1
838. Push Dominoes

class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        dominoes = list(dominoes)
        n = len(dominoes)
        last_right = -1
        last_left = 0

        for i, d in enumerate(dominoes):
            if d == 'R':
                if last_right != -1:
                    for j in range(last_right + 1, i):
                        dominoes[j] = 'R'
                last_right = i
            elif d == 'L':
                if last_right != -1:
                    l, r = last_right + 1, i - 1
                    while l < r:
                        dominoes[l], dominoes[r] = 'R', 'L'
                        l += 1
                        r -= 1
                    last_right = -1
                else:
                    for j in range(last_left, i):
                        dominoes[j] = 'L'
                last_left = i

        if last_right != -1:
            for i in range(last_right + 1, n):
                dominoes[i] = 'R'

        return ''.join(dominoes)
1007. Minimum Domino Rotations For Equal Row

class Solution:
    def minDominoRotations(self, tops, bottoms):
        res = float('inf')
        for val in range(1, 7):
            top_swaps = bottom_swaps = 0
            valid = True
            for t, b in zip(tops, bottoms):
                if t != val and b != val:
                    valid = False
                    break
                if t != val:
                    top_swaps += 1
                if b != val:
                    bottom_swaps += 1
            if valid:
                res = min(res, top_swaps, bottom_swaps)
        return -1 if res == float('inf') else res
1128. Number of Equivalent Domino Pairs

class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        f=[0]*100
        c=0
        for i, j in dominoes:
            if i<j:
                x=10*i+j
            else:
                x=10*j+i
            c+=f[x]
            f[x]+=1
        return c
790. Domino and Tromino Tiling

class Solution:
    def numTilings(self, n: int) -> int:
        MOD = 10**9 + 7
        dp = [0] * (max(4, n + 1))
        dp[1], dp[2], dp[3] = 1, 2, 5
        for i in range(4, n + 1):
            dp[i] = (2 * dp[i - 1] + dp[i - 3]) % MOD
        return dp[n]
1920. Build Array from Permutation

class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        return [nums[nums[i]] for i in range(len(nums))]
3341. Find Minimum Time to Reach Last Room I

import heapq

class Solution:
    def minTimeToReach(self, moveTime):
        m, n = len(moveTime), len(moveTime[0])
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        heap = [(0, 0, 0)]  # time, row, col

        while heap:
            time, r, c = heapq.heappop(heap)
            if (r, c) == (m-1, n-1):
                return time
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n:
                    wait_time = max(time, moveTime[nr][nc]) + 1
                    if wait_time < dist[nr][nc]:
                        dist[nr][nc] = wait_time
                        heapq.heappush(heap, (wait_time, nr, nc))
        return -1

3342. Find Minimum Time to Reach Last Room II

import heapq

class Solution:
    def minTimeToReach(self, moveTime):
        n, m = len(moveTime), len(moveTime[0])
        vis = [[False] * m for _ in range(n)]
        heap = [(0, 0, 0, 0)]  # (time, moves, row, col)
        vis[0][0] = True
        dirs = [(0,1), (1,0), (-1,0), (0,-1)]

        while heap:
            time, moves, r, c = heapq.heappop(heap)
            if r == n - 1 and c == m - 1:
                return time
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < m and not vis[nr][nc]:
                    vis[nr][nc] = True
                    wait = max(time, moveTime[nr][nc])
                    travel_time = 1 if moves % 2 == 0 else 2
                    heapq.heappush(heap, (wait + travel_time, moves + 1, nr, nc))
        return -1
3343. Count Number of Balanced Permutations

MOD = 10**9 + 7

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        cnt = Counter(int(ch) for ch in num)
        total = sum(int(ch) for ch in num)

        if total % 2 != 0:
            return 0

        half_sum = total // 2
        n = len(num)
        even_count = n // 2
        odd_count = n - even_count

        @lru_cache(maxsize=None)
        def dfs(digit, odd, even, balance):
            if odd == 0 and even == 0 and balance == 0:
                return 1
            if digit < 0 or odd < 0 or even < 0 or balance < 0:
                return 0

            res = 0
            for j in range(0, cnt[digit] + 1):
                odd_used = j
                even_used = cnt[digit] - j
                if odd_used > odd or even_used > even:
                    continue
                comb_odd = comb(odd, odd_used)
                comb_even = comb(even, even_used)
                res += comb_odd * comb_even * dfs(
                    digit - 1,
                    odd - odd_used,
                    even - even_used,
                    balance - digit * odd_used
                )
                res %= MOD
            return res

        return dfs(9, odd_count, even_count, half_sum)
2918. Minimum Equal Sum of Two Arrays After Replacing Zeros

class Solution:
    def minSum(self, nums1, nums2):
        nums1_sum = sum(x if x != 0 else 1 for x in nums1)
        nums2_sum = sum(x if x != 0 else 1 for x in nums2)

        nums1_zeros = nums1.count(0)
        nums2_zeros = nums2.count(0)

        if (nums1_zeros == 0 and nums2_sum > nums1_sum) or \
           (nums2_zeros == 0 and nums1_sum > nums2_sum):
            return -1
        return max(nums1_sum, nums2_sum)
1550. Three Consecutive Odds

class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        for i in range(len(arr) - 2):
            if arr[i] % 2 + arr[i + 1] % 2 + arr[i + 2] % 2 == 3:
                return True
        return False
2094. Finding 3-Digit Even Numbers

class Solution:
    def findEvenNumbers(self, dig: List[int]) -> List[int]:        
        arr = []
        for i in range(100, 999):
            flag = True
            seen = Counter(dig)
            for s in str(i):
                if int(s) not in seen:
                    flag = False
                    break
                else:
                    seen[int(s)] -= 1
                    if seen[int(s)] == 0:
                        del seen[int(s)]
            if flag and i % 2 == 0:
                arr.append(i)
        
        return arr
3335. Total Characters in String After Transformations I

class Solution:
    def lengthAfterTransformations(self, s: str, t: int) -> int:
        l=1
        mod=10**9+7
        if  len(set(s))==1:
            l=len(s)
            s=s[0]
        def fn(chrs):
            b = [0]*26
            for i in chrs:
                x = ord(i) - ord('a')
                b[x] += 1
            return b
        def fn3(lst):
            b=[0]*26
            n = len(lst)
            ll=[]
            for i in range(n):
                if lst[i]>0:
                    ll.append((i, lst[i]))
            for p,i in ll:
                if p==25:
                    b[0]+=i%mod
                    b[1]+=i%mod
                else:
                    b[p+1]+=i
                b[p]=0 if b[p]-1<0 else b[p]
            return b
        b=fn(s)

        for i in range(t):
            b=fn3(b)
        
        return (sum(b)*l)%mod
3337. Total Characters in String After Transformations II

class Solution:
    def lengthAfterTransformations(self, s: str, t: int, nums: List[int]) -> int:
        mod = 10**9 + 7
        vector = [[0] * 26 for _ in range(26)]
        for c in range(26):
            num = nums[c]
            for j in range(1, num + 1):
                next_c = (c + j) % 26
                vector[c][next_c] += 1

        def matrix_multi(x, y):
            res = [[0] * 26 for _ in range(26)]
            for i in range(26):
                for j in range(26):
                    if x[i][j] == 0:
                        continue
                    for l in range(26):
                        res[i][l] = (res[i][l] + x[i][j] * y[j][l]) % mod
            return res

        def matrix_pol(m, n):
            total = [[1 if i == j else 0 for j in range(26)] for i in range(26)]
            while n > 0:
                if n % 2 == 1:
                    total = matrix_multi(total, m)
                m = matrix_multi(m, m)
                n //= 2
            return total
        compute = matrix_pol(vector, t)

        cnt = [0] * 26
        for c in s:
            cnt[ord(c) - ord('a')] += 1
            
        new_cnt =[0] * 26
        for i in range(26):
            for j in range(26):
                new_cnt[j] = (new_cnt[j] + cnt[i] * compute[i][j]) % mod
                         
        result = 0
        for x in new_cnt:
            result = (result + x) % mod
        return result
2900. Longest Unequal Adjacent Groups Subsequence I

class Solution:
    def getLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:
        res = [words[0]]
        lastBit = groups[0]
        for i in range(1, len(words)):
            if groups[i] != lastBit:
                res.append(words[i])
                lastBit ^= 1
                
        return res
2901. Longest Unequal Adjacent Groups Subsequence II

class Solution:
    def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:
        n = len(words)
        connections = {}
        maxs = {}
        result = []

        def HammingDistance(base, word):
            differences = 0
            
            if len(base) != len(word):
                return -1
            else:
                for i in range(len(word)):
                    if base[i] != word[i]: differences += 1
                    if differences > 2: return -1
            return differences

        for i in range(n):
            connections[i] = []
            for k in range(i, n):
                if groups[i] != groups[k] and HammingDistance(words[i], words[k]) == 1:
                    connections[i].append(k)
        
        for i in range(n - 1, -1, -1):
            maxs[i] = []

            for connection in connections[i]:
                if len(maxs[connection]) > len(maxs[i]):
                    maxs[i] = maxs[connection]
            
            maxs[i] = [words[i]] + maxs[i]
            if len(maxs[i]) > len(result):
                result = maxs[i]

        return result
75. Sort Colors

class Solution {
    public void sortColors(int[] nums) {
        int n=nums.length;
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                if(nums[i]>nums[j]){
                    int temp=nums[i];
                    nums[i]=nums[j];
                    nums[j]=temp;
                }
            }
        }
    }
}
1931. Painting a Grid With Three Different Colors

class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        from itertools import product
        from collections import defaultdict

        MOD = 10**9 + 7
        def is_valid(col):
            return all(col[i] != col[i + 1] for i in range(len(col) - 1))

        colors = [0, 1, 2]  
        valid_cols = []
        for col in product(colors, repeat=m):
            if is_valid(col):
                valid_cols.append(col)
        compatible = {}
        for c1 in valid_cols:
            compatible[c1] = []
            for c2 in valid_cols:
                if all(a != b for a, b in zip(c1, c2)):
                    compatible[c1].append(c2)
        dp = defaultdict(int)
        for col in valid_cols:
            dp[col] = 1
        for _ in range(1, n):
            new_dp = defaultdict(int)
            for col in valid_cols:
                for prev in compatible[col]:
                    new_dp[col] = (new_dp[col] + dp[prev]) % MOD
            dp = new_dp

        return sum(dp.values()) % MOD
3024. Type of Triangle

class Solution:
    def triangleType(self, nums: List[int]) -> str:
        nums.sort()
        if nums[2]>=nums[0]+nums[1]: return "none"
        if nums[0]==nums[2]: return "equilateral"
        if nums[0]==nums[1] or nums[1]==nums[2]: return "isosceles"
        return "scalene"
3355. Zero Array Transformation I

class Solution:
    def isZeroArray(self, nums, queries):
        n = len(nums)
        q = [0] * (n + 1)
        for start, end in queries:
            q[start] += 1
            if end + 1 < len(q):
                q[end + 1] -= 1
        for i in range(1, n):
            q[i] += q[i - 1]
        for i in range(n):
            if q[i] < nums[i]:
                return False
        return True
Set Matrix Zeroes

class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        rows = len(matrix)
        cols = len(matrix[0])

        first_row_has_zero = any(matrix[0][y] == 0 for y in range(cols))
        first_col_has_zero = any(matrix[x][0] == 0 for x in range(rows))

        for x in range(1, rows):
            for y in range(1, cols):
                if matrix[x][y] == 0:
                    matrix[x][0] = 0
                    matrix[0][y] = 0

        for x in range(1, rows):
            if matrix[x][0] == 0:
                for y in range(cols):
                    matrix[x][y] = 0

        for y in range(1, cols):
            if matrix[0][y] == 0:
                for x in range(rows):
                    matrix[x][y] = 0

        if first_row_has_zero:
            for y in range(cols):
                matrix[0][y] = 0

        if first_col_has_zero:
            for x in range(rows):
                matrix[x][0] = 0
3362. Zero Array Transformation III

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        intervals = sorted(queries, key=lambda x: x[0])
        idx = 0
        avail = []
        active = []
        chosen = 0

        for i in range(n):
            while active and active[0] < i:
                heapq.heappop(active)

            coverage = len(active)
            while idx < m and intervals[idx][0] <= i:
                l, r = intervals[idx]
                heapq.heappush(avail, (-r, r))
                idx += 1

            demand = nums[i]
            while coverage < demand:
                while avail and avail[0][1] < i:
                    heapq.heappop(avail)
                if not avail:
                    return -1
                _, r = heapq.heappop(avail)
                heapq.heappush(active, r)
                chosen += 1
                coverage += 1

        return m - chosen   
3068. Find the Maximum Sum of Node Values

class Solution:
    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
        n=len(nums)
        @cache
        def f(i, c):
            if i==n:
                if c==1: return -(1<<31)
                return 0
            x=nums[i]
            return max(x+f(i+1, c),(x^k)+f(i+1,1-c))
        return f(0, 0)
2942. Find Words Containing Character

class Solution:
    def findWordsContaining(self, words: List[str], x: str) -> List[int]:
        return [i for i, w in enumerate(words) if w.find(x)!=-1]
2131. Longest Palindrome by Concatenating Two Letter Words

class Solution:
    def longestPalindrome(self, words: List[str]) -> int:
        wordCount = Counter(words)
        length = 0
        hasMiddle = False
        
        for word in wordCount:
            reverseWord = word[::-1]
            
            if word == reverseWord:
                pairs = wordCount[word] // 2
                length += pairs * 4
                
                if wordCount[word] % 2 == 1 and not hasMiddle:
                    hasMiddle = True
                    length += 2
            
            elif word < reverseWord and reverseWord in wordCount:
                pairs = min(wordCount[word], wordCount[reverseWord])
                length += pairs * 4
        
        return length   
1857. Largest Color Value in a Directed Graph

class Solution:
    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:
        hashmap = collections.defaultdict(list)

        for u, v in edges:
            if u == v:
                return -1
            hashmap[u].append(v)

        visited = set()
        
        @cache
        def dfs(curr, target):
            result = 0
            for adj in hashmap[curr]:
                if adj in visited:
                    return float('inf')
                visited.add(adj)
                result = max(result, dfs(adj, target))
                visited.remove(adj)

            return result + 1 if colors[curr] == target else result

        max_path_value = 0
        for i in range(len(colors)):
            max_path_value = max(max_path_value, dfs(i, colors[i]))

        return -1 if max_path_value == float('inf') else max_path_value
2894. Divisible and Non-divisible Sums Difference

class Solution:
    def differenceOfSums(self, n: int, m: int) -> int:
        return n*(n+1)//2-m*(n//m)*(n//m+1)

3372. Maximize the Number of Target Nodes After Connecting Trees I

from collections import deque
from typing import List

class Solution:
    def maxTargetNodes(self, edges1: List[List[int]], edges2: List[List[int]], k: int) -> List[int]:
        def build_graph(edges):
            n = len(edges) + 1
            graph = [[] for _ in range(n)]
            for u, v in edges:
                graph[u].append(v)
                graph[v].append(u)
            return graph

        def bfs_count_max(graph, max_dist):
            n = len(graph)
            result = [0] * n
            for start in range(n):
                visited = [False] * n
                q = deque()
                q.append((start, 0))
                visited[start] = True
                count = 1
                while q:
                    node, dist = q.popleft()
                    if dist == max_dist:
                        continue
                    for neighbor in graph[node]:
                        if not visited[neighbor]:
                            visited[neighbor] = True
                            q.append((neighbor, dist + 1))
                            count += 1
                result[start] = count
            return result

        g1 = build_graph(edges1)
        g2 = build_graph(edges2)

        if k == 0:
            return [1] * len(g1)

        cnt1 = bfs_count_max(g1, k)
        cnt2 = bfs_count_max(g2, k - 1)
        max_cnt2 = max(cnt2)

        return [cnt + max_cnt2 for cnt in cnt1]
3373. Maximize the Number of Target Nodes After Connecting Trees II

class Solution:
    def maxTargetNodes(self, edges1: List[List[int]], edges2: List[List[int]]) -> List[int]:
        def find_even(edges: list, n : int) -> list:
            graph = [[] for _ in range(n)]
            queue = deque([(0, -1, True)])
            evens = [False] * n
            for u, v in edges:
                graph[u].append(v)
                graph[v].append(u)
            while queue:
                node, parent, is_even = queue.popleft()
                evens[node] = is_even
                for child in graph[node]:
                    if child == parent:
                        continue
                    queue.append((child, node, not is_even))
            return evens
        n1, n2 = len(edges1) + 1, len(edges2) + 1
        even1, even2 = find_even(edges1, n1), find_even(edges2, n2)
        total1, total2 = sum(even1), sum(even2)
        mx = max(total2, n2 - total2)
        ans = [mx + (total1 if even else n1 - total1) for even in even1]
        return ans
2359. Find Closest Node to Given Two Nodes

class Solution:
    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:
        n=len(edges)
        inf=1<<32
        dist1=[inf]*n
        dist2=[inf]*n
        def dfs(node, dist):
            d, i=0, node
            while i!=-1 and dist[i]==inf:
                dist[i]=d
                d+=1
                i=edges[i]
        dfs(node1, dist1)
        dfs(node2, dist2)
        minD, index=inf, -1
        for i in range(n):
            max12=max(dist1[i], dist2[i])
            if max12<minD: 
                minD=max12
                index=i
        return index

        

        
        
        
                    





        

        



        
        

        
        
         
        
        
        
        
        
        
        
        
        


        
        

          
        
       
        
        
        
        
        
        
        


        


